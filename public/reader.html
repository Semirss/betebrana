<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BeteBrana - Universal Document Reader</title>
    <!-- Element UI CSS -->
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #dcdcdc;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><rect width="10" height="10" fill="%23dcdcdc"/><path d="M-1,1l2,-2m0,4l2,-2m0,4l2,-2" stroke="%23c0c0c0" stroke-width="1"/></svg>');
            transform: scale(0.8);
            transform-origin: center;
        }
        
        /* Book Container */
        .book {
            width: 90vw;
            max-width: 1200px;
            height: 85vh;
            max-height: 800px;
            display: flex;
            background-color: #8B4513!important;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            position: relative;
            transform-style: preserve-3d;
            transform: perspective(2000px);
            padding: 10px;
            transition: background-color 0.3s ease;
        }
        /* Offline disabled state */
.el-button.is-disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.offline-warning {
    color: #f56c6c;
    font-size: 12px;
    text-align: center;
    padding: 5px;
    background: #fef0f0;
    border-radius: 4px;
    margin: 5px 0;
}
        .pages-container {
            width: 100%;
            height: 100%;
            display: flex;
            background-color: #fff;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
        }
        
        .page {
            width: 50%;
            padding: 20px;
            box-sizing: border-box;
            background-color: #8B4513; /* SaddleBrown for the cover */
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            transform-style: preserve-3d;
            transition: transform 0.5s ease, background-color 0.3s, color 0.3s;
            overflow-y: auto;
        }
        
        .left-page {
            border-right: 2px solid #ddd;
            box-shadow: inset 5px 0 10px rgba(0, 0, 0, 0.1);
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
            transform-origin: right;
            z-index: 2;
        }
        
        .right-page {
            border-left: 2px solid #ddd;
            box-shadow: inset -5px 0 10px rgba(0, 0, 0, 0.1);
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
            transform-origin: left;
            z-index: 1;
        }
        
        /* App specific styles */
        #app {
            width: 100%;
            height: 100%;
        }
        
        /* Reader View */
        .reader-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: #fff;
            color: #000;
            border-radius: 5px;
            transition: background-color 0.3s, color 0.3s;
        }
        
        .reader-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background-color: rgba(0,0,0,0.05);
            flex-shrink: 0;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        
        .reader-content {
            flex-grow: 1;
            position: relative;
            overflow-y: auto;
        }
        
        .reader-footer {
            padding: 5px 20px;
            background-color: rgba(0,0,0,0.05);
            flex-shrink: 0;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        
        .book-title {
            font-weight: bold;
            font-size: 16px;
        }
        
        .control-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        /* Login View */
        .login-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        
        .login-title {
            text-align: center;
            font-size: 28px;
            margin-bottom: 25px;
            color: #333;
        }
        
        .login-error {
            color: #f56c6c;
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #fef0f0;
            border-radius: 4px;
            width: 100%;
        }
        
        /* Library & Dashboard Views */
        .library-container, .dashboard-container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .library-header, .dashboard-header {
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .library-header h1, .dashboard-header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .book-list {
            overflow-y: auto;
            flex-grow: 1;
            padding: 5px;
        }
        
        .book-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 5px;
            margin-bottom: 8px;
        }
        
        .book-item:hover {
            background-color: #f9f9f9;
        }
        
        .book-cover {
            width: 60px;
            height: 80px;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .book-cover .placeholder {
            font-size: 24px;
            color: #8B4513;
        }
        
        .book-info {
            flex-grow: 1;
        }
        
        .book-info h3 {
            margin: 0 0 5px;
            font-size: 14px;
        }
        
        .book-info p {
            margin: 0;
            font-size: 12px;
            color: #777;
        }
        
        .file-type {
            font-size: 10px;
            font-weight: bold;
            color: #fff;
            background-color: #8B4513;
            padding: 2px 5px;
            border-radius: 3px;
            display: inline-block;
            margin-top: 5px;
        }
        
        .book-actions, .rental-actions {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .empty-library {
            text-align: center;
            margin-top: 50px;
            color: #999;
            padding: 20px;
        }
        
        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #e4e7ed;
        }
        
        .nav-tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .nav-tab.active {
            border-bottom-color: #409eff;
            color: #409eff;
        }
        
        .nav-tab:hover {
            color: #409eff;
        }
        
        /* Dashboard Elements */
        .dashboard-section {
            margin-bottom: 20px;
        }
        
        .dashboard-subtitle {
            font-size: 16px;
            margin-bottom: 10px;
            color: #409eff;
        }
        
        .rental-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 5px;
        }
        
        .status-active {
            background-color: #e6f7e6;
            color: #2e7d32;
        }
        
        .status-due {
            background-color: #fff3e0;
            color: #ef6c00;
        }
        
        .status-overdue {
            background-color: #ffebee;
            color: #c62828;
        }
        
        /* Countdown Timer */
        .countdown-timer {
            font-size: 12px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .countdown-overdue {
            color: #c62828;
        }
        
        .countdown-due {
            color: #ef6c00;
        }
        
        .countdown-normal {
            color: #2e7d32;
        }
        
        /* EPUB Reader */
        #epub-container {
            padding: 20px;
            height: 100%;
            overflow-y: auto;
        }
        
        /* PDF Reader */
        #pdf-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            transition: background 0.3s ease;
        }
        
        .pdf-page {
            margin: 10px auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        /* DOCX/DOC Content */
        .docx-content {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: white;
            min-height: 100%;
            transition: all 0.3s ease;
        }
        
        .docx-content h1 {
            font-size: 1.5em;
            margin-bottom: 15px;
            border-bottom: 2px solid #e4e7ed;
            padding-bottom: 8px;
            transition: all 0.3s ease;
        }
        
        .docx-content h2 {
            font-size: 1.3em;
            margin: 20px 0 12px 0;
            transition: all 0.3s ease;
        }
        
        .docx-content p {
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }
        
        /* TXT Content */
        .txt-content {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            white-space: pre-wrap;
            font-family: inherit;
            background: white;
            min-height: 100%;
            transition: all 0.3s ease;
        }
        
        .loading {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: #888;
            flex-direction: column;
            gap: 15px;
        }
        
        .error-message {
            color: #f56c6c;
            text-align: center;
            margin-top: 20px;
        }
        
        /* THEME STYLES */
        
        /* Light Theme (Default) */
        .theme-light {
            background: #ffffff;
            color: #333333;
        }
        
        .theme-light .reader-header,
        .theme-light .reader-footer {
            background: #f5f7fa;
            color: #333333;
            border-color: #e4e7ed;
        }
        
        .theme-light .docx-content,
        .theme-light .txt-content {
            background: #ffffff;
            color: #333333;
        }
        
        .theme-light .docx-content h1,
        .theme-light .docx-content h2 {
            color: #333333;
            border-bottom-color: #e4e7ed;
        }
        
        .theme-light #pdf-container {
            background: #525659;
        }
        
        /* Dark Theme */
        .theme-dark {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .theme-dark .reader-header,
        .theme-dark .reader-footer {
            background: #2d2d2d;
            color: #e0e0e0;
            border-color: #404040;
        }
        
        .theme-dark .docx-content,
        .theme-dark .txt-content {
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        .theme-dark .docx-content h1,
        .theme-dark .docx-content h2 {
            color: #e0e0e0;
            border-bottom-color: #404040;
        }
        
        .theme-dark .docx-content table,
        .theme-dark .docx-content th,
        .theme-dark .docx-content td {
            border-color: #404040;
        }
        
        .theme-dark #pdf-container {
            background: #2d2d2d;
        }
        
        .theme-dark .page,
        .theme-dark .reader-container,
        .theme-dark .el-dialog {
            background-color: #2c2c2c !important;
            color: #e0e0e0 !important;
        }
        
        .theme-dark .left-page {
            border-right-color: #444;
        }
        
        .theme-dark .right-page {
            border-left-color: #444;
        }
        
        .theme-dark .login-title,
        .theme-dark h1,
        .theme-dark h3 {
            color: #f0f0f0;
        }
        
        .theme-dark .book-item:hover {
            background-color: #383838;
        }
        
        .theme-dark .el-input__inner {
            background-color: #333;
            border-color: #555;
            color: #fff;
        }
        
        /* Tan Theme */
        .theme-tan {
            background: #fdf6e3;
            color: #586e75;
        }
        
        .theme-tan .reader-header,
        .theme-tan .reader-footer {
            background: #eee8d5;
            color: #657b83;
            border-color: #d5c9a7;
        }
        
        .theme-tan .docx-content,
        .theme-tan .txt-content {
            background: #fdf6e3;
            color: #586e75;
        }
        
        .theme-tan .docx-content h1,
        .theme-tan .docx-content h2 {
            color: #586e75;
            border-bottom-color: #d5c9a7;
        }
        
        .theme-tan #pdf-container {
            background: #f0e8d5;
        }
        
        .theme-tan .page,
        .theme-tan .reader-container,
        .theme-tan .el-dialog {
            background-color: #fdf6e3 !important;
            color: #586e75 !important;
        }
        
        .theme-tan .left-page {
            border-right-color: #eee8d5;
        }
        
        .theme-tan .right-page {
            border-left-color: #eee8d5;
        }
        
        .theme-tan .login-title,
        .theme-tan h1,
        .theme-tan h3 {
            color: #073642;
        }
        
        .theme-tan .book-item:hover {
            background-color: #eee8d5;
        }
        
        /* Blue Theme */
        .theme-blue {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .theme-blue .reader-header,
        .theme-blue .reader-footer {
            background: #bbdefb;
            color: #0d47a1;
            border-color: #90caf9;
        }
        
        .theme-blue .docx-content,
        .theme-blue .txt-content {
            background: #e3f2fd;
            color: #1565c0;
        }
        
        .theme-blue .docx-content h1,
        .theme-blue .docx-content h2 {
            color: #0d47a1;
            border-bottom-color: #90caf9;
        }
        
        .theme-blue #pdf-container {
            background: #bbdefb;
        }
        
        /* Green Theme */
        .theme-green {
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .theme-green .reader-header,
        .theme-green .reader-footer {
            background: #c8e6c9;
            color: #1b5e20;
            border-color: #a5d6a7;
        }
        
        .theme-green .docx-content,
        .theme-green .txt-content {
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .theme-green .docx-content h1,
        .theme-green .docx-content h2 {
            color: #1b5e20;
            border-bottom-color: #a5d6a7;
        }
        
        .theme-green #pdf-container {
            background: #c8e6c9;
        }
        
        /* Theme Previews */
        .theme-preview {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
            border: 2px solid transparent;
        }
        
        .theme-light .theme-preview { background: linear-gradient(45deg, #ffffff 50%, #333333 50%); }
        .theme-dark .theme-preview { background: linear-gradient(45deg, #2d2d2d 50%, #e0e0e0 50%); }
        .theme-tan .theme-preview { background: linear-gradient(45deg, #eee8d5 50%, #657b83 50%); }
        .theme-blue .theme-preview { background: linear-gradient(45deg, #bbdefb 50%, #1565c0 50%); }
        .theme-green .theme-preview { background: linear-gradient(45deg, #c8e6c9 50%, #2e7d32 50%); }
        
        /* Welcome Page */
        .welcome-page {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            text-align: center;
        }
        
        .welcome-page h1 {
            font-size: 36px;
            color: #8B4513;
            margin-bottom: 15px;
        }
        
        .welcome-page p {
            font-size: 18px;
            color: #555;
        }
        
        /* Mobile Navigation */
        .mobile-nav {
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(0,0,0,0.05);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            margin-bottom: 15px;
        }
        
        .mobile-nav-title {
            font-weight: bold;
            font-size: 18px;
        }
        
        .mobile-nav-tabs {
            display: flex;
            gap: 10px;
        }
        
        .mobile-nav-tab {
            padding: 8px 12px;
            border-radius: 4px;
            background-color: #f0f0f0;
            cursor: pointer;
            font-size: 14px;
        }
        
        .mobile-nav-tab.active {
            background-color: #409eff;
            color: white;
        }
        
        /* Remove dialog backdrop */
        .v-modal {
            display: none !important;
        }
        
        .el-dialog__wrapper {
            background-color: transparent !important;
        }
        
        .el-dialog {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            border: 1px solid rgba(0, 0, 0, 0.1) !important;
        }
        
        /* Responsive design adjustments */
        @media (max-width: 900px) {
            body {
                background-color: #fff;
                align-items: flex-start;
                padding: 10px;
            }
            
            .book {
                width: 100%;
                height: 100%;
                flex-direction: column;
                box-shadow: none;
                border-radius: 0;
                padding: 0;
                transform: none;
                max-height: none;
            }
            
            .pages-container {
                flex-direction: column;
                border-radius: 0;
            }
            
            .page {
                width: 100%;
                border: none !important;
                box-shadow: none !important;
                transform: none !important;
                height: 50%;
            }
            
            .left-page {
                border-bottom: 2px solid #ddd;
            }
            
            .reader-container {
                border-radius: 0;
            }
            
            .library-header h1, .dashboard-header h1 {
                font-size: 20px;
            }
            
            .nav-tabs {
                display: none;
            }
            
            .mobile-nav {
                display: flex;
            }
            
            .book-item {
                padding: 8px;
            }
            
            .book-cover {
                width: 50px;
                height: 70px;
                margin-right: 10px;
            }
            
            .book-info h3 {
                font-size: 13px;
            }
            
            .book-info p {
                font-size: 11px;
            }
            
            /* Mobile-specific layout for dashboard */
            .dashboard-container .nav-tabs {
                display: none;
            }
            
            .dashboard-section {
                margin-bottom: 15px;
            }
            
            .rental-actions {
                flex-direction: column;
                gap: 3px;
            }
            
            .rental-actions .el-button {
                padding: 5px 8px;
                font-size: 12px;
            }
        }
        
        @media (max-width: 600px) {
            .control-group {
                gap: 5px;
            }
            
            .reader-header {
                padding: 5px 10px;
            }
            
            .book-title {
                font-size: 14px;
            }
            
            .el-button--small {
                padding: 7px 9px;
            }
            
            .el-button--mini {
                padding: 5px;
            }
            
            .el-button.is-circle {
                padding: 8px;
            }
            
            .book-cover {
                width: 40px;
                height: 60px;
            }
            
            .book-cover .placeholder {
                font-size: 18px;
            }
            
            .mobile-nav-tab {
                padding: 6px 10px;
                font-size: 12px;
            }
        }
        /* Queue Status Styles */
.availability-info {
    margin: 5px 0;
}

.availability-status {
    font-size: 11px;
    padding: 2px 6px;
    border-radius: 10px;
    display: inline-block;
}

.status-available {
    background-color: #e6f7e6;
    color: #2e7d32;
}

.status-unavailable {
    background-color: #fff3e0;
    color: #ef6c00;
}

.status-queue {
    background-color: #e3f2fd;
    color: #1565c0;
}

.queue-badge {
    font-size: 10px;
    background-color: #2196f3;
    color: white;
    padding: 2px 6px;
    border-radius: 8px;
    margin-left: 5px;
}

.queue-position {
    margin-top: 3px;
}

.queue-actions small {
    color: #666;
    font-size: 10px;
}

/* Queue counter in library header */
.queue-counter {
    background-color: #ff9800;
    color: white;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    margin-left: 5px;
}
/* Enhanced Queue Status Styles */
.availability-info {
    margin: 5px 0;
    line-height: 1.4;
}
 .bookmark {
                right: 20px;
                height: 40px;
                width: 30px;
            }
    .bookmark {
            position: absolute;
            top: 0;
            right: 20px; /* Adjusted position */
            width: 20px; /* Thinner bookmark */
            height: 60px; /* Shorter bookmark */
            background-color: #8B4513; /* Same color as the book cover */
            z-index: 10;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 50% 100%, 0 80%); /* Creates the pointed bottom */
        }

.availability-status {
    font-size: 11px;
    padding: 4px 8px;
    border-radius: 10px;
    display: inline-block;
    font-weight: 500;
}

.status-available {
    background-color: #e6f7e6;
    color: #2e7d32;
    border: 1px solid #4caf50;
}

.status-first-queue {
    background-color: #e8f5e9;
    color: #1b5e20;
    border: 1px solid #66bb6a;
    animation: pulse 2s infinite;
}

.status-in-queue {
    background-color: #e3f2fd;
    color: #1565c0;
    border: 1px solid #2196f3;
}

.status-reserved {
    background-color: #fff3e0;
    color: #ef6c00;
    border: 1px solid #ff9800;
}

.status-unavailable {
    background-color: #ffebee;
    color: #c62828;
    border: 1px solid #f44336;
}

.queue-countdown {
    margin-top: 3px;
}

.queue-countdown small {
    color: #666;
    font-size: 10px;
    font-style: italic;
}

/* Pulsing animation for first in queue */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.02); }
    100% { transform: scale(1); }
}

/* Queue position badge */
.queue-position-badge {
    background: linear-gradient(45deg, #2196f3, #21cbf3);
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 5px;
}

/* Queue statistics in header */
.queue-stats {
    display: flex;
    gap: 15px;
    margin-top: 10px;
    font-size: 12px;
}

.queue-stat {
    display: flex;
    align-items: center;
    gap: 5px;
}

.queue-stat-number {
    background: #2196f3;
    color: white;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
}
/* Add to your CSS */
.queue-countdown-timer {
    margin-top: 5px;
    padding: 3px 8px;
    background: linear-gradient(45deg, #ff9800, #ff5722);
    color: white;
    border-radius: 12px;
    font-size: 10px;
    font-weight: bold;
    animation: pulse 1.5s infinite;
}

.queue-position-info {
    margin-top: 3px;
    font-size: 10px;
    color: #666;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

/* Enhanced status styles */
.status-first-queue {
    background: linear-gradient(45deg, #4caf50, #8bc34a) !important;
    color: white !important;
    border: 2px solid #388e3c !important;
    font-weight: bold;
}
/* ===== CRITICAL FALLBACK STYLES ===== */
/* These ensure the book structure works even when JS fails */

/* Base fallback styles that work without Vue/Element UI */
#app:not(.vue-loaded) {
    opacity: 1 !important;
    visibility: visible !important;
}

/* Ensure book structure is visible even if Vue fails to load */
.book {
    min-height: 600px;
    opacity: 1 !important;
    transform: none !important;
}

/* Fallback for when Element UI buttons don't load */
.control-group .el-button:not([class*="el-icon"])::before {
    content: "";
    margin-right: 5px;
}

.el-button[icon="el-icon-back"]:not(.el-button)::before { content: "‚Üê"; }
.el-button[icon="el-icon-arrow-left"]:not(.el-button)::before { content: "‚óÄ"; }
.el-button[icon="el-icon-arrow-right"]:not(.el-button)::before { content: "‚ñ∂"; }
.el-button[icon="el-icon-zoom-out"]:not(.el-button)::before { content: "üîç-"; }
.el-button[icon="el-icon-zoom-in"]:not(.el-button)::before { content: "üîç+"; }
.el-button[icon="el-icon-switch-button"]:not(.el-button)::before { content: "üö™"; }

/* Fallback form styles when Element UI fails */
.el-form:not(.el-form) {
    display: block;
    width: 100%;
}

.el-input:not(.el-input) {
    display: block;
    width: 100%;
    padding: 12px;
    margin: 8px 0;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
}

.el-button:not(.el-button) {
    display: inline-block;
    padding: 12px 24px;
    background: #409eff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-decoration: none;
    font-size: 14px;
}

.el-button:not(.el-button):hover {
    background: #66b1ff;
}

/* Fallback for dialog when Element UI fails */
.el-dialog__wrapper:not(.el-dialog__wrapper) {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.el-dialog:not(.el-dialog) {
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    min-width: 300px;
    max-width: 90vw;
}

/* Loading and error states */
.loading-fallback {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100%;
    flex-direction: column;
    gap: 15px;
}

.error-fallback {
    background: #fef0f0;
    color: #f56c6c;
    padding: 20px;
    border-radius: 4px;
    text-align: center;
    margin: 20px;
}
/* Add to your existing CSS */
/* Fallback button styles when Element UI fails */
.el-button:not(.el-button) {
    display: inline-block;
    padding: 8px 15px;
    background: #409eff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    text-decoration: none;
    font-size: 14px;
    margin: 2px;
    min-width: 40px;
    min-height: 40px;
}

.el-button.is-circle:not(.el-button) {
    border-radius: 50%;
    padding: 8px;
}

.el-button.is-disabled:not(.el-button) {
    opacity: 0.6;
    cursor: not-allowed;
    background: #c0c4cc;
}

/* Fallback for button icons when Element UI fails */
.el-button[icon]:not(.el-button)::before {
    content: "";
    display: inline-block;
    margin-right: 5px;
}

.el-button[icon="el-icon-back"]:not(.el-button)::before { content: "‚Üê"; }
.el-button[icon="el-icon-arrow-left"]:not(.el-button)::before { content: "‚óÄ"; }
.el-button[icon="el-icon-arrow-right"]:not(.el-button)::before { content: "‚ñ∂"; }
.el-button[icon="el-icon-zoom-out"]:not(.el-button)::before { content: "‚àí"; }
.el-button[icon="el-icon-zoom-in"]:not(.el-button)::before { content: "+"; }
.el-button[icon="el-icon-switch-button"]:not(.el-button)::before { content: "‚èª"; }

/* Ensure reader header buttons are always visible */
.reader-header .control-group {
    display: flex !important;
    gap: 8px;
}

.reader-header .el-button {
    visibility: visible !important;
    opacity: 1 !important;
    display: flex !important;
}

/* Force show essential reader controls even when offline */
.reader-header .control-group .el-button:not(.el-button) {
    background: #8B4513 !important;
    border: 1px solid #654321 !important;
}

/* Specific styling for reader controls */
.reader-controls {
    display: flex !important;
    gap: 5px;
}

/* Ensure buttons don't disappear in offline mode */
body.offline .reader-header .el-button,
body.offline .reader-footer .el-button {
    display: inline-flex !important;
    visibility: visible !important;
    opacity: 1 !important;
}
/* Offline detection banner */
.offline-banner {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background: #ff9800;
    color: white;
    padding: 10px;
    text-align: center;
    z-index: 10000;
    font-size: 14px;
}

/* Ensure content is always visible */
.reader-content,
.library-container,
.dashboard-container,
.login-container {
    opacity: 1 !important;
    visibility: visible !important;
}

/* Fallback for Vue conditional rendering */
[v-if]:not(.vue-rendered) {
    display: block !important;
}

/* Make sure book pages are always properly structured */
.pages-container {
    min-height: 400px;
}

.page {
    min-height: 300px;
}

/* Fallback navigation */
.nav-tabs:not(.vue-rendered) {
    display: flex;
}

.nav-tab:not(.vue-rendered) {
    padding: 10px 15px;
    cursor: pointer;
}

/* Book list fallback */
.book-list:not(.vue-rendered) {
    display: block;
}

.book-item:not(.vue-rendered) {
    display: flex;
    padding: 10px;
    border-bottom: 1px solid #eee;
}
/* ===== DIALOG FALLBACK STYLES FOR OFFLINE MODE ===== */

/* Fix for broken dialogs when Element UI fails to load */
.el-dialog__wrapper[style*="display: none"] {
    display: none !important;
}

.el-dialog__wrapper:not([style]) {
    display: none;
}

/* When Element UI fails, provide basic dialog styling */
.el-dialog:not(.el-dialog) {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    background: white !important;
    border-radius: 8px !important;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3) !important;
    z-index: 2001 !important;
    min-width: 300px !important;
    max-width: 90vw !important;
    padding: 20px !important;
}

.el-dialog__header:not(.el-dialog__header) {
    padding: 0 0 15px 0 !important;
    margin: 0 !important;
    border-bottom: 1px solid #e4e7ed !important;
    font-weight: bold !important;
    font-size: 18px !important;
}

.el-dialog__body:not(.el-dialog__body) {
    padding: 15px 0 !important;
    margin: 0 !important;
}

.el-dialog__footer:not(.el-dialog__footer) {
    padding: 15px 0 0 0 !important;
    margin: 0 !important;
    border-top: 1px solid #e4e7ed !important;
    text-align: right !important;
}

/* Backdrop for dialogs */
.v-modal:not(.v-modal) {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0,0,0,0.5) !important;
    z-index: 2000 !important;
}

/* Fix for radio buttons in settings dialog */
.el-radio-group:not(.el-radio-group) {
    display: flex !important;
    flex-direction: column !important;
    gap: 10px !important;
}

.el-radio:not(.el-radio) {
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
    cursor: pointer !important;
}

/* Form fallbacks */
.el-form-item:not(.el-form-item) {
    margin-bottom: 15px !important;
}

.el-form-item__label:not(.el-form-item__label) {
    display: block !important;
    margin-bottom: 5px !important;
    font-weight: bold !important;
}

/* Input number fallback */
.el-input-number:not(.el-input-number) {
    display: flex !important;
    align-items: center !important;
    gap: 5px !important;
}

.el-input-number__decrease:not(.el-input-number__decrease),
.el-input-number__increase:not(.el-input-number__increase) {
    padding: 5px 10px !important;
    background: #f5f7fa !important;
    border: 1px solid #dcdfe6 !important;
    cursor: pointer !important;
}

.el-input-number__decrease:not(.el-input-number__decrease):hover,
.el-input-number__increase:not(.el-input-number__increase):hover {
    background: #e4e7ed !important;
}
/* Navigation Mode Styles */
.navigation-mode {
    overflow: hidden !important;
}

.navigation-mode .reader-content {
    overflow: hidden !important;
    position: relative;
}

.page-navigation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
}

.page-navigation .el-button {
    min-width: 100px;
}

.page-info {
    font-size: 14px;
    color: #666;
    margin: 0 15px;
}

/* PDF Navigation Mode */
.pdf-navigation-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
    overflow: hidden;
}

.pdf-navigation-view {
    flex: 1;
    overflow-y: auto;
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.pdf-navigation-view .pdf-page {
    margin: 10px auto;
    display: block;
}

/* EPUB Navigation Mode */
.epub-navigation-container {
    height: 100%;
    overflow: hidden;
    position: relative;
}

/* DOCX/TXT Navigation Mode */
.content-navigation-container {
    height: 100%;
    overflow: hidden;
    position: relative;
}

.content-navigation-view {
    height: calc(100% - 60px);
    overflow-y: auto;
}

.navigation-controls {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 10px;
    border-radius: 20px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    z-index: 100;
}

/* Navigation toggle button */
.navigation-toggle {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 100;
}

/* Theme support for navigation controls */
.theme-dark .navigation-controls {
    background: rgba(45, 45, 45, 0.9);
    color: #e0e0e0;
}

.theme-tan .navigation-controls {
    background: rgba(238, 232, 213, 0.9);
    color: #586e75;
}

.theme-blue .navigation-controls {
    background: rgba(187, 222, 251, 0.9);
    color: #1565c0;
}

.theme-green .navigation-controls {
    background: rgba(200, 230, 201, 0.9);
    color: #2e7d32;
}
/* DELETE THIS DUPLICATE SECTION - it's already defined above */
.navigation-mode .txt-content {
    max-width: 210mm; /* A4 width */
    min-height: 297mm; /* A4 height */
    margin: 0 auto;
    padding: 25mm; /* Standard A4 margins */
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    line-height: 1.6;
    white-space: pre-wrap;
    font-family: inherit;
    box-sizing: border-box;
    overflow: hidden;
}

/* DELETE THIS DUPLICATE TOO */
.txt-page-navigation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
}

.txt-page-info {
    font-size: 14px;
    color: #666;
    min-width: 120px;
    text-align: center;
}
/* KEEP THIS SECTION - FIX THE DIMENSIONS */
.navigation-mode .txt-content {
    width: 210mm; /* A4 width - FIXED */
    height: 297mm; /* A4 height - FIXED */
    margin: 10px auto; /* Added margin */
    padding: 20mm; /* Reduced padding */
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    line-height: 1.6;
    white-space: pre-wrap;
    font-family: inherit;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* KEEP THIS - Fix container for proper layout */
.txt-page-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    align-items: center;
    justify-content: center;
}

/* KEEP THIS - Fix navigation positioning */
.txt-page-navigation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
    padding: 10px;
}
/* Fix for scroll mode - ensure content is visible and scrollable */
.reader-content:not(.navigation-mode) {
    overflow-y: auto !important;
}

/* Fix for A4 paper in navigation mode - ensure content fits and is visible */
.navigation-mode .txt-content {
    width: 210mm !important;
    height: 297mm !important;
    margin: 10px auto !important;
    padding: 20mm !important;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    line-height: 1.6;
    white-space: pre-wrap;
    font-family: inherit;
    box-sizing: border-box;
    overflow: auto !important; /* Changed from hidden to auto */
    display: block !important;
}

/* Ensure PDF pages are properly displayed in both modes */
#pdf-container {
    overflow: auto !important;
}

.pdf-navigation-container {
    overflow: auto !important;
}

/* Fix for DOCX content in navigation mode */
.navigation-mode .docx-content {
    max-width: 210mm;
    min-height: 297mm;
    margin: 10px auto;
    padding: 20mm;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    overflow: auto !important;
}
/* Hide footer for all book types */
.reader-footer {
    display: none !important;
}

/* OR hide only for specific book types */
.reader-footer[v-if*="epub"],
.reader-footer[v-if*="pdf"] {
    display: none !important;
}
.txt-content {
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}

.txt-content::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera */
}
</style>
</head>
<body>
    <!-- Loading Screen -->
<div id="initial-loading" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; display: flex; justify-content: center; align-items: center; z-index: 9999; flex-direction: column; gap: 20px;">
    <div style="font-size: 24px; color: #8B4513;">üìö BeteBrana</div>
    <div style="display: flex; gap: 10px;">
        <div style="width: 12px; height: 12px; background: #8B4513; border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both;"></div>
        <div style="width: 12px; height: 12px; background: #8B4513; border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both; animation-delay: 0.16s;"></div>
        <div style="width: 12px; height: 12px; background: #8B4513; border-radius: 50%; animation: bounce 1.4s infinite ease-in-out both; animation-delay: 0.32s;"></div>
    </div>
    <div style="color: #666; font-size: 14px;">Loading your digital library...</div>
</div>

<style>
@keyframes bounce {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1); }
}
/* Add this to your CSS - Force hide all dialogs when offline */
body.offline .el-dialog,
body.offline .el-dialog__wrapper,
body.offline .v-modal {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
}
</style>

<script>
// Hide loading screen when app is ready
window.addEventListener('load', function() {
    setTimeout(function() {
        const loading = document.getElementById('initial-loading');
        if (loading) {
            loading.style.display = 'none';
        }
    }, 1000);
});

// Also hide if Vue initializes
document.addEventListener('vue-ready', function() {
    const loading = document.getElementById('initial-loading');
    if (loading) {
        loading.style.display = 'none';
    }
});
</script>
    <div id="app" class="book" :class="`theme-${theme}`">
        <!-- Reader View (takes over the whole book) -->
        <div v-if="isAuthenticated && currentBook" class="reader-container" :class="`theme-${theme}`">
            <!-- Reader Header -->
         <!-- Reader Header -->
<div class="reader-header">
    <div class="control-group">
        <el-button icon="el-icon-back" circle @click="closeBook" size="small"></el-button>
        <el-button v-if="currentBook.type === 'epub'" icon="el-icon-arrow-left" circle @click="prevPage" size="small"></el-button>
        <el-button v-if="currentBook.type === 'epub'" icon="el-icon-arrow-right" circle @click="nextPage" size="small"></el-button>
    </div>
    <div class="book-title">{{ currentBook.title }}</div>
    <div class="control-group">
        <!-- Navigation Toggle Button -->
        <el-tooltip :content="navigationMode ? 'Switch to Scroll Mode' : 'Switch to Page Navigation'" placement="bottom">
            <el-button 
                :icon="navigationMode ? 'el-icon-sort' : 'el-icon-document'" 
                circle 
                @click="toggleNavigationMode" 
                size="small"
                :type="navigationMode ? 'primary' : ''">
            </el-button>
        </el-tooltip>
        
        <el-button icon="el-icon-zoom-out" circle @click="zoomOut" size="small"></el-button>
        <el-button icon="el-icon-zoom-in" circle @click="zoomIn" size="small"></el-button>
        <el-button icon="el-icon-switch-button" circle @click="logout" size="small"></el-button>
    </div>
</div>
            
          <!-- Reader Content -->
<div class="reader-content" :class="{ 'navigation-mode': navigationMode }">
    <div v-if="!isReady" class="loading">
        <el-button type="text" :loading="true">Loading {{ currentBook.type.toUpperCase() }}...</el-button>
        <div v-if="loadError" class="error-message">
            {{ loadError }}
        </div>
    </div>
    
    <!-- EPUB Reader -->
    <div v-else-if="currentBook.type === 'epub'" 
         :class="{ 'epub-navigation-container': navigationMode }"
         :id="navigationMode ? 'epub-navigation-container' : 'epub-container'">
    </div>
    
    <!-- PDF Reader -->
    <div v-else-if="currentBook.type === 'pdf'" 
         :class="{ 'pdf-navigation-container': navigationMode }"
         :id="navigationMode ? 'pdf-navigation-container' : 'pdf-container'">
        
        <div v-if="navigationMode" class="pdf-navigation-view">
            <canvas v-for="page in pdfPages" 
                    :key="page.pageNumber" 
                    :id="`pdf-page-${page.pageNumber}`" 
                    class="pdf-page"
                    :style="{ display: currentPdfPage === page.pageNumber ? 'block' : 'none' }">
            </canvas>
        </div>
        <div v-else>
            <canvas v-for="page in pdfPages" 
                    :key="page.pageNumber" 
                    :id="`pdf-page-${page.pageNumber}`" 
                    class="pdf-page">
            </canvas>
        </div>
        
        <!-- PDF Navigation Controls -->
        <div v-if="navigationMode && currentBook.type === 'pdf'" class="navigation-controls">
            <el-button 
                icon="el-icon-arrow-left" 
                @click="prevPdfPage"
                :disabled="currentPdfPage <= 1"
                size="small">
                Previous
            </el-button>
            <span class="page-info">
                Page {{ currentPdfPage }} of {{ pdfPages.length }}
            </span>
            <el-button 
                icon="el-icon-arrow-right" 
                @click="nextPdfPage"
                :disabled="currentPdfPage >= pdfPages.length"
                size="small">
                Next
            </el-button>
        </div>
    </div>
    
    <!-- DOCX/DOC Reader -->
    <div v-else-if="currentBook.type === 'docx' || currentBook.type === 'doc'" 
         :class="{ 'content-navigation-container': navigationMode }">
        
        <div :class="{ 'content-navigation-view': navigationMode }" class="docx-content" v-html="docxContent"></div>
        
        <!-- DOCX Navigation Controls -->
        <div v-if="navigationMode" class="navigation-controls">
            <el-button 
                icon="el-icon-arrow-up" 
                @click="scrollContent(-300)"
                size="small">
                Scroll Up
            </el-button>
            <el-button 
                icon="el-icon-arrow-down" 
                @click="scrollContent(300)"
                size="small">
                Scroll Down
            </el-button>
        </div>
    </div>
<!-- TXT Reader -->
<div v-else-if="currentBook.type === 'txt'" 
     :class="{ 'content-navigation-container': navigationMode }">
    
    <!-- Navigation Mode -->
    <div v-if="navigationMode" class="txt-page-container">
        <div class="content-navigation-view">
            <div class="txt-content">
                {{ currentTxtPageContent }}
            </div>
        </div>
        
        <div class="navigation-controls">
            <el-button 
                icon="el-icon-arrow-left" 
                @click="prevTxtPage"
                :disabled="currentTxtPage <= 1"
                size="small">
                Previous
            </el-button>
            <span class="page-info">
                Page {{ currentTxtPage }} of {{ totalTxtPages }}
            </span>
            <el-button 
                icon="el-icon-arrow-right" 
                @click="nextTxtPage"
                :disabled="currentTxtPage >= totalTxtPages"
                size="small">
                Next
            </el-button>
        </div>
    </div>
    
    <!-- Scroll Mode (Original) -->
    <div v-else class="txt-content scroll-mode">
        {{ txtContent }}
    </div>
</div>
</div>
            <!-- Footer -->
            <div class="reader-footer" v-if="currentBook.type === 'epub' || currentBook.type === 'pdf'">
                <el-slider 
                    v-model="progress" 
                    :format-tooltip="formatProgress" 
                    @change="onProgressChange"
                    style="width: 100%">
                </el-slider>
            </div>
        </div>
        
        <!-- Main Library & Dashboard View -->
        <div v-else class="pages-container">
            <!-- Left Page: Welcome or Dashboard -->
            <div class="left-page page" :class="`theme-${theme}`">
                <div v-if="!isAuthenticated" class="welcome-page">
                    <h1>BeteBrana</h1>
                    <p>Your Digital Library</p>
                </div>
                <div v-else class="dashboard-container">
                    <!-- Mobile Navigation -->
                    <div class="mobile-nav">
                        <div class="mobile-nav-title">My Library</div>
                        
                        <div class="mobile-nav-tabs">
                            <div class="mobile-nav-tab" :class="{ active: currentTab === 'rentals' }" @click="currentTab = 'rentals'">Borrowed</div>
                            <div class="mobile-nav-tab" :class="{ active: currentTab === 'queue' }" @click="currentTab = 'queue'">Queue</div>
                                <div class="mobile-nav-tab" :class="{ active: currentTab === 'downloaded' }" @click="currentTab = 'downloaded'">Downloaded</div>

                        </div>
                    </div>
                    
                    <div class="nav-tabs">
                        <div class="nav-tab" :class="{ active: currentTab === 'rentals' }" @click="currentTab = 'rentals'">Borrowed</div>
                        <div class="nav-tab" :class="{ active: currentTab === 'queue' }" @click="currentTab = 'queue'">Queue</div>
                             <div class="nav-tab" :class="{ active: currentTab === 'downloaded' }" @click="currentTab = 'downloaded'" >Downloaded</div>
                        <el-button icon="el-icon-s-operation" circle @click="showSettings" size="small" style="margin-left: 150px; padding-left: 10px; margin-bottom:5px; width:40px; height:40px"></el-button>

                        <el-button icon="el-icon-switch-button" circle @click="logout" size="small" style=" margin-bottom:5px; width:40px; height:40px"></el-button>

                    </div>
                    
                    <!-- Currently Rented Books -->
                    <div v-if="currentTab === 'rentals'" class="dashboard-section">
                        <h3 class="dashboard-subtitle">Currently Borrowed Books</h3>
                        <div v-if="userRentals.length === 0" class="empty-library">
                            <p>You have no Borrowed books</p>
                        </div>
                        <div v-else class="book-list">
                            <div v-for="rental in userRentals" :key="rental.id" class="book-item" @click="openRentedBook(rental)">
                                <div class="book-cover">
                                    <img v-if="rental.cover_image" :src="`http://localhost:3000${rental.cover_image}`" :alt="rental.title">
                                    <div v-else class="placeholder">
                                        <span v-if="getBookFileType(rental.book_id) === 'pdf'">üìÑ</span>
                                        <span v-else-if="getBookFileType(rental.book_id) === 'docx' || getBookFileType(rental.book_id) === 'doc'">üìù</span>
                                        <span v-else-if="getBookFileType(rental.book_id) === 'txt'">üìÉ</span>
                                        <span v-else>üìÅ</span>
                                    </div>
                                </div>
                                <div class="book-info" id="offlinebook">
                                    <h3>{{ rental.title }}</h3>
                                    <p>{{ rental.author || 'Unknown Author' }}</p>
                                    <div class="rental-status" :class="getRentalStatusClass(rental)">
                                        {{ getRentalStatusText(rental) }}
                                    </div>
                                    <div class="countdown-timer" :class="getCountdownClass(rental)">
                                        {{ getTimeRemaining(rental) }}
                                    </div>
                                </div>
                          <div class="rental-actions">
    <el-button 
        type="primary" 
        size="mini" 
        @click.stop="openRentedBook(rental)"
        :disabled="offlineMode"
        :title="offlineMode ? 'You are offline' : 'Read book'">
        Read
    </el-button>
    <el-button 
        type="success" 
        size="mini" 
        @click.stop="downloadRentedBook(rental)" 
        :disabled="offlineMode"
        :title="offlineMode ? 'You are offline' : 'Download for offline reading'">
        Download
    </el-button>
    <el-button 
        type="warning" 
        size="mini" 
        @click.stop="returnBook(rental)"
        :disabled="offlineMode"
        :title="offlineMode ? 'You are offline' : 'Return book'">
        Return
    </el-button>
</div>
</div>
                        </div>
                    </div>
                    
                    <!-- Your Queue -->
                    <div v-if="currentTab === 'queue'" class="dashboard-section">
                        <h3 class="dashboard-subtitle">Your Queue</h3>
                        <div v-if="userQueue.length === 0" class="empty-library">
                            <p>Your queue is empty</p>
                        </div>
                        <div v-else class="book-list">
                            <div v-for="item in userQueue" :key="item.id" class="book-item">
                                <div class="book-cover">
                                    <img v-if="item.cover_image" :src="`http://localhost:3000${item.cover_image}`" :alt="item.title">
                                    <div v-else class="placeholder">
                                        <span v-if="getBookFileType(item.book_id) === 'pdf'">üìÑ</span>
                                        <span v-else-if="getBookFileType(item.book_id) === 'docx' || getBookFileType(item.book_id) === 'doc'">üìù</span>
                                        <span v-else-if="getBookFileType(item.book_id) === 'txt'">üìÉ</span>
                                        <span v-else>üìÅ</span>
                                    </div>
                                </div>
                                <div class="book-info" id="offlinebook">
                                    <h3>{{ item.title }}</h3>
                                    <p>{{ item.author || 'Unknown Author' }}</p>
                                    <p>Added: {{ formatDate(item.added_at) }}</p>
                                    <span class="file-type">{{ getBookFileType(item.book_id) ? getBookFileType(item.book_id).toUpperCase() : 'UNKNOWN' }}</span>
                                </div>
                                <div class="rental-actions">
                                    <el-button type="primary" size="mini" 
                                               @click.stop="rentBookFromQueue(item)"
                                               :disabled="!isBookAvailable(item.book_id)">Borrow Now</el-button>
                                    <el-button type="danger" size="mini" @click.stop="removeFromQueue(item)">Remove</el-button>
                                </div>
                            </div>
                        </div>
                    </div>
                      <!-- Downloaded Files Section -->
<div v-if="currentTab === 'downloaded'" class="dashboard-section">
    <h3 class="dashboard-subtitle">Downloaded Files</h3>
    <div v-if="downloadedBooks.length === 0" class="empty-library">
        <p>No downloaded books available offline</p>
      
    </div>
    <div v-else class="book-list">
        <div v-for="book in downloadedBooks" :key="book.id" class="book-item" @click="openDownloadedBook(book)">
            <div class="book-cover">
                <img v-if="book.cover_image" :src="book.cover_image" :alt="book.title">
                <div v-else class="placeholder">
                    <span v-if="book.file_type === 'pdf'">üìÑ</span>
                    <span v-else-if="book.file_type === 'docx' || book.file_type === 'doc'">üìù</span>
                    <span v-else-if="book.file_type === 'txt'">üìÉ</span>
                    <span v-else>üìÅ</span>
                </div>
            </div>
            <div class="book-info">
                <h3>{{ book.title }}</h3>
                <p>{{ book.author || 'Unknown Author' }}</p>
                <div class="availability-info">
                    <span class="availability-status status-available">
                        Available Offline
                    </span>
                    <div class="countdown-timer" :class="getDownloadCountdownClass(book)">
                        Expires: {{ getDownloadTimeRemaining(book) }}
                    </div>
                </div>
                <span class="file-type">{{ book.file_type ? book.file_type.toUpperCase() : 'UNKNOWN' }}</span>
            </div>
            <div class="rental-actions">
                <el-button type="primary" size="mini" @click.stop="openDownloadedBook(book)">Read</el-button>
                <el-button type="danger" size="mini" @click.stop="removeDownloadedBook(book)">Remove</el-button>
            </div>
        </div>
    </div>
</div>
                </div>
            </div>
          
            <!-- Right Page: Login or Library -->
            <div class="right-page page" :class="`theme-${theme}`">
                <div class="bookmark"></div>
                <!-- Login View -->
                <div v-if="!isAuthenticated" class="login-container">
                    <h2 class="login-title">Library Login</h2>
                    <div v-if="loginError" class="login-error">{{ loginError }}</div>
                    <el-form :model="loginForm" :rules="loginRules" ref="loginForm" style="width: 80%;">
                        <el-form-item prop="email">
                            <el-input v-model="loginForm.email" placeholder="Email" prefix-icon="el-icon-user"></el-input>
                        </el-form-item>
                        <el-form-item prop="password">
                            <el-input v-model="loginForm.password" type="password" placeholder="Password" prefix-icon="el-icon-lock" show-password></el-input>
                        </el-form-item>
                        <el-form-item>
                            <el-button type="primary" style="width: 100%" :loading="loginLoading" @click="handleLogin">Login</el-button>
                        </el-form-item>
                        <el-form-item>
                            <el-button style="width: 100%" @click="showRegister = true">Register</el-button>
                        </el-form-item>
                    </el-form>
                </div>
                
                <!-- Library View -->
                <div v-else class="library-container">
                    <div class="library-header">
                        <h1>Document Library</h1>
                    </div>
                    
                    <div class="nav-tabs">
                        <div class="nav-tab" :class="{ active: currentTab === 'all' }" @click="currentTab = 'all'">All Books</div>
                        <div class="nav-tab" :class="{ active: currentTab === 'available' }" @click="currentTab = 'available'">Available</div>
                    </div>
                    
                    <div v-if="filteredBooks.length === 0" class="empty-library">
                        <h3>No documents available</h3>
                        <p>Books will appear here once they're added to the system.</p>
                    </div>
                    
                    <div v-else class="book-list">
                     <div v-for="book in filteredBooks" :key="book.id" class="book-item" @click="openBook(book)">
    <div class="book-cover">
        <img v-if="book.cover_image" :src="`http://localhost:3000${book.cover_image}`" :alt="book.title">
        <div v-else class="placeholder">
            <span v-if="book.file_type === 'pdf'">üìÑ</span>
            <span v-else-if="book.file_type === 'docx' || book.file_type === 'doc'">üìù</span>
            <span v-else-if="book.file_type === 'txt'">üìÉ</span>
            <span v-else>üìÅ</span>
        </div>
    </div>
<div class="book-info" id="offlinebook">
    <h3>{{ book.title }}</h3>
    <p>{{ book.author || 'Unknown Author' }}</p>
    
    <!-- Queue and Availability Information -->
    <div class="availability-info">
        <span class="availability-status" :class="getQueueStatusDisplay(book).class">
            {{ getQueueStatusDisplay(book).text }}
        </span>
        
        <!-- Countdown Timer - Only show when book is reserved for user -->
        <div v-if="book.queueInfo && book.queueInfo.hasReservation && book.queueInfo.timeRemaining > 0" 
             class="queue-countdown-timer">
            <small>borrowing within: {{ formatQueueTimeRemaining(book.queueInfo.timeRemaining) }}</small>
        </div>
        
        <!-- Show queue position details -->
        <div v-else-if="book.queueInfo && book.queueInfo.userInQueue && !book.queueInfo.hasReservation" 
             class="queue-position-info">
            <small>You are position {{ book.queueInfo.userPosition }} of {{ book.queueInfo.totalInQueue }}</small>
        </div>
    </div>
    
    <span class="file-type">{{ book.file_type ? book.file_type.toUpperCase() : 'UNKNOWN' }}</span>
</div>
<div class="book-actions">
  <!-- Show rent button if user has reservation -->
  <el-button v-if="book.queueInfo && book.queueInfo.hasReservation" 
             size="mini" 
             type="success" 
             @click.stop="rentBook(book)">
    Borrow Now (Reserved!)
  </el-button>
  
  <!-- Show rent button if book is available and no reservations exist -->
  <el-button v-else-if="book.available_copies > 0 && book.queueInfo && book.queueInfo.totalInQueue === 0" 
             size="mini" 
             type="primary" 
             @click.stop="rentBook(book)">
    Borrow Now
  </el-button>
  
  <!-- Show join queue button if book is unavailable -->
  <el-button v-else-if="book.queueInfo && book.queueInfo.canJoinQueue"
             size="mini" 
             type="warning" 
             @click.stop="addToQueue(book)"
             :disabled="hasRentedBook(book.id)">
    Join Queue
  </el-button>
  
  <!-- Show leave queue button if in queue but no reservation yet -->
  <el-button v-else-if="book.queueInfo && book.queueInfo.userInQueue && !book.queueInfo.hasReservation"
             size="mini" 
             type="danger" 
             @click.stop="removeFromQueue(getQueueItem(book.id))">
    Leave Queue
  </el-button>
</div>
        
        <!-- Add to favorites (always available) -->
        <el-button v-if="!hasQueuedBook(book.id) && book.queueInfo && !book.queueInfo.userInQueue"
                   size="mini" 
                   icon="el-icon-star-off" 
                   circle 
                   @click.stop="addToQueue(book)"
                   title="Add to queue">
        </el-button>
    </div>
</div>
                </div>
            </div>
        </div>

        <!-- Register Dialog -->
        <el-dialog id="offlinetoremove" title="Register" :visible.sync="showRegister" width="400px" :class="`theme-${theme}`">
            <el-form :model="registerForm" :rules="registerRules" ref="registerForm">
                <el-form-item label="Name" prop="name">
                    <el-input v-model="registerForm.name"></el-input>
                </el-form-item>
                <el-form-item label="Email" prop="email">
                    <el-input v-model="registerForm.email"></el-input>
                </el-form-item>
                <el-form-item label="Password" prop="password">
                    <el-input v-model="registerForm.password" type="password" show-password></el-input>
                </el-form-item>
            </el-form>
            <div slot="footer">
                <el-button @click="showRegister = false">Cancel</el-button>
                <el-button type="primary" :loading="registerLoading" @click="handleRegister">Register</el-button>
            </div>
        </el-dialog>

        <!-- Search Dialog -->
        <el-dialog title="Search" :visible.sync="searchVisible" width="500px" :class="`theme-${theme}`">
            <el-input v-model="searchText" placeholder="Enter search term" @input="onSearch"></el-input>
            <div class="search-results" style="max-height: 300px; overflow-y: auto; margin-top: 15px;">
                <div v-if="searchResults.length === 0 && searchText" style="text-align: center; color: #909399; padding: 20px;">
                    No results found for "{{ searchText }}"
                </div>
                <div v-for="result in searchResults" :key="result.index" class="search-result" 
                     @click="goToSearchResult(result)" style="padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; line-height: 1.4;">
                    <div style="font-size: 12px; color: #409eff; margin-bottom: 4px;">
                        Result {{ result.index + 1 }}
                    </div>
                    {{ result.text }}
                </div>
            </div>
        </el-dialog>
        
        <!-- Settings Dialog -->
        <el-dialog id="offlinetoremove" title="Reading Settings" :visible.sync="settingsVisible"    width="400px" :class="`theme-${theme}`">
            <el-form label-width="100px">
                <el-form-item label="Theme">
                    <el-radio-group v-model="theme" @change="applyTheme" class="theme-selector">
                        <el-radio label="light">
                            <span class="theme-preview"></span>
                            Light
                        </el-radio>
                        <el-radio label="dark">
                            <span class="theme-preview"></span>
                            Dark
                        </el-radio>
                        <el-radio label="tan">
                            <span class="theme-preview"></span>
                            Tan
                        </el-radio>
                        <el-radio label="blue">
                            <span class="theme-preview"></span>
                            Blue
                        </el-radio>
                        <el-radio label="green">
                            <span class="theme-preview"></span>
                            Green
                        </el-radio>
                    </el-radio-group>
                </el-form-item>
                
                <el-form-item label="Font Size">
                    <el-input-number v-model="fontSize" :min="12" :max="24" :step="2"></el-input-number>
                </el-form-item>
                
                <el-form-item label="Zoom Level">
                    <el-input-number v-model="zoomLevel" :min="0.5" :max="3" :step="0.1" :precision="1"></el-input-number>
                </el-form-item>
            </el-form>
        </el-dialog>
    </div>

    <!-- Libraries -->
    <script src="https://unpkg.com/vue@2.6.14/dist/vue.js"></script>
    <!-- <script src="https://unpkg.com/element-ui/lib/index.js"></script> -->
    <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
    <script src="https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
<!-- Change from: -->
<link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
<script src="https://unpkg.com/element-ui/lib/index.js"></script>

<!-- To: -->
<link rel="stylesheet" href="/node_modules/element-ui/lib/theme-chalk/index.css">
<script src="/node_modules/element-ui/lib/index.js"></script>
    <script>
        // Set PDF.js worker path
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@3.4.120/build/pdf.worker.min.js';

        // API Configuration
        const API_BASE = 'http://localhost:3000/api';
// Encryption Utilities
class SecureStorage {
    constructor() {
        this.dbName = 'BeteBranaSecureDB';
        this.dbVersion = 1;
        this.db = null;
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('encryptedBooks')) {
                    const store = db.createObjectStore('encryptedBooks', { keyPath: 'id' });
                    store.createIndex('expiry', 'expiry', { unique: false });
                }
            };
        });
    }

    async generateKey() {
        const deviceId = await this.getDeviceId();
        const encoder = new TextEncoder();
        const data = encoder.encode(deviceId + 'BeteBranaSecret2024');
        const hash = await crypto.subtle.digest('SHA-256', data);
        return crypto.subtle.importKey(
            'raw',
            hash,
            { name: 'AES-GCM' },
            false,
            ['encrypt', 'decrypt']
        );
    }

    async getDeviceId() {
        let deviceId = localStorage.getItem('deviceId');
        if (!deviceId) {
            deviceId = crypto.randomUUID();
            localStorage.setItem('deviceId', deviceId);
        }
        return deviceId;
    }

    async encryptData(data) {
        const key = await this.generateKey();
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encoder = new TextEncoder();
        const encodedData = encoder.encode(JSON.stringify(data));
        
        const encrypted = await crypto.subtle.encrypt(
            {
                name: 'AES-GCM',
                iv: iv
            },
            key,
            encodedData
        );

        return {
            iv: Array.from(iv),
            data: Array.from(new Uint8Array(encrypted)),
            timestamp: Date.now()
        };
    }

    async decryptData(encryptedData) {
        try {
            const key = await this.generateKey();
            const iv = new Uint8Array(encryptedData.iv);
            const data = new Uint8Array(encryptedData.data);
            
            const decrypted = await crypto.subtle.decrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );

            const decoder = new TextDecoder();
            return JSON.parse(decoder.decode(decrypted));
        } catch (error) {
            console.error('Decryption failed:', error);
            throw new Error('Failed to decrypt book - device mismatch or file corrupted');
        }
    }

    async saveBook(bookId, bookData, expiryDate) {
        if (!this.db) await this.init();
        
        const encrypted = await this.encryptData(bookData);
        const transaction = this.db.transaction(['encryptedBooks'], 'readwrite');
        const store = transaction.objectStore('encryptedBooks');
        
        await store.put({
            id: bookId,
            data: encrypted,
            expiry: expiryDate.getTime(),
            downloadedAt: new Date().toISOString()
        });
    }

    async getBook(bookId) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['encryptedBooks'], 'readonly');
        const store = transaction.objectStore('encryptedBooks');
        
        return new Promise((resolve, reject) => {
            const request = store.get(bookId);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async removeBook(bookId) {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['encryptedBooks'], 'readwrite');
        const store = transaction.objectStore('encryptedBooks');
        
        await store.delete(bookId);
    }

    async getAllBooks() {
        if (!this.db) await this.init();
        
        const transaction = this.db.transaction(['encryptedBooks'], 'readonly');
        const store = transaction.objectStore('encryptedBooks');
        
        return new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    async cleanupExpired() {
        const books = await this.getAllBooks();
        const now = Date.now();
        
        for (const book of books) {
            if (book.expiry < now) {
                await this.removeBook(book.id);
            }
        }
    }
}

// Initialize secure storage
const secureStorage = new SecureStorage();
      new Vue({
    el: '#app',
    data() {
        return {
        currentTxtPage: 1,
        totalTxtPages: 1,
        txtPages: [],
        currentTxtPageContent: '',
        navigationMode: false,
        currentPdfPage: 1,
            // Authentication
            isAuthenticated: false,
            token: null,
            user: null,
            loginForm: {
                email: '',
                password: ''
            },
            loginRules: {
                email: [
                    { required: true, message: 'Please enter email', trigger: 'blur' },
                    { type: 'email', message: 'Please enter a valid email', trigger: 'blur' }
                ],
                password: [
                    { required: true, message: 'Please enter password', trigger: 'blur' }
                ]
            },
            registerForm: {
                name: '',
                email: '',
                password: ''
            },
            registerRules: {
                name: [
                    { required: true, message: 'Please enter name', trigger: 'blur' }
                ],
                email: [
                    { required: true, message: 'Please enter email', trigger: 'blur' },
                    { type: 'email', message: 'Please enter a valid email', trigger: 'blur' }
                ],
                password: [
                    { required: true, message: 'Please enter password', trigger: 'blur' },
                    { min: 6, message: 'Password must be at least 6 characters', trigger: 'blur' }
                ]
            },
            showRegister: false,
            loginLoading: false,
            registerLoading: false,
            loginError: '',
            
            // Navigation
            currentView: 'library',
            currentTab: 'rentals', // Default to rentals on mobile
            
            // Reader state
            currentBook: null,
            bookList: [],
            userRentals: [],
            userQueue: [],
            isReady: false,
            loadError: null,
            progress: 0,
            searchVisible: false,
            searchText: '',
            searchResults: [],
            settingsVisible: false,
            theme: 'light',
            fontSize: 16,
            zoomLevel: 1.0,
            downloadedBooks: [],
            offlineMode: false,
            // EPUB
            rendition: null,
            book: null,
            
            // PDF
            pdfDoc: null,
            pdfPages: [],
            
            // DOCX/DOC
            docxContent: '',
            
            // TXT
            txtContent: '',
            
            // Timer for countdown updates
            countdownTimer: null,
            queueTimer: null,
        };
    },
    
    computed: {
        filteredBooks() {
            if (this.currentTab === 'available') {
                return this.bookList.filter(book => book.available_copies > 0);
            }
            return this.bookList;
        },
        
        // Check if we're on mobile
        isMobile() {
            return window.innerWidth <= 900;
        },
        
        // ADD THIS MISSING COMPUTED PROPERTY:
        queuableBooks() {
            return this.bookList.filter(book => 
                book.available_copies <= 0 && 
                !this.hasRentedBook(book.id) && 
                !this.hasQueuedBook(book.id)
            );
        }
    },
async mounted() {
    // Check for existing authentication
    const token = localStorage.getItem('reader-token');
    const user = localStorage.getItem('reader-user');
    
    if (token && user) {
        this.token = token;
        this.user = JSON.parse(user);
        this.isAuthenticated = true;
        
        // Load saved theme from localStorage
        const savedTheme = localStorage.getItem('reader-theme');
        if (savedTheme) {
            this.theme = savedTheme;
        }
         // Load navigation mode preference
    const savedNavigationMode = localStorage.getItem('reader-navigation-mode');
    if (savedNavigationMode) {
        this.navigationMode = savedNavigationMode === 'true';
    }
    
        // Initialize secure storage
        await secureStorage.init();
        
        // Load downloaded books
        await this.loadDownloadedBooks();
        
        await this.loadLibrary();
        await this.loadUserData();
        this.applyTheme();
        
        // Start countdown timer for rentals
        this.startCountdownTimer();
        
        // Start queue timer updates
        this.startQueueTimer();
        
        // Check offline status
        this.checkOfflineStatus();
        
        // Watch for register dialog when offline
        this.$watch('showRegister', (newVal) => {
            if (newVal && !navigator.onLine) {
                this.$message.warning('Registration unavailable while offline');
                this.showRegister = false;
            }
        });
    }
    
    // Set initial tab based on screen size
    if (this.isMobile) {
        this.currentTab = 'rentals';
    }
    
    // Add resize listener
    window.addEventListener('resize', this.handleResize);
    
    // Add online/offline listeners
    window.addEventListener('online', this.checkOfflineStatus);
    window.addEventListener('offline', this.checkOfflineStatus);
},

methods: {
     // NEW: Enhanced toggleNavigationMode to handle A4 formatting and pagination
// Enhanced toggleNavigationMode to properly handle both modes
// Enhanced toggleNavigationMode to handle initialization properly
toggleNavigationMode() {
    this.navigationMode = !this.navigationMode;
    
    // Use nextTick to ensure DOM is updated before manipulating content
    this.$nextTick(() => {
        if (this.navigationMode && this.currentBook.type === 'txt') {
            this.paginateTxtContent();
        }
        
        // Reset to first page when switching to navigation mode
        if (this.navigationMode) {
            if (this.currentBook.type === 'pdf') {
                this.currentPdfPage = 1;
            } else if (this.currentBook.type === 'txt') {
                this.currentTxtPage = 1;
                this.currentTxtPageContent = this.txtPages[0] || '';
            }
        }
        
        // Force re-render of content
        this.applyZoom();
    });
},
    
    // NEW: Paginate TXT content for A4 paper navigation
// UPDATE this method for better pagination
paginateTxtContent() {
    if (!this.txtContent || this.currentBook.type !== 'txt') return;
    
    // Reset pagination
    this.txtPages = [];
    this.currentTxtPage = 1;
    
    // Better pagination: split by lines to fit A4 page
    const lines = this.txtContent.split('\n');
    const linesPerPage = 40; // Adjust based on your font size
    let currentPageLines = [];
    
    for (let i = 0; i < lines.length; i++) {
        currentPageLines.push(lines[i]);
        
        if (currentPageLines.length >= linesPerPage || i === lines.length - 1) {
            this.txtPages.push(currentPageLines.join('\n'));
            currentPageLines = [];
        }
    }
    
    this.totalTxtPages = this.txtPages.length;
    this.currentTxtPageContent = this.txtPages[0] || '';
},
    
    // NEW: Navigate to next TXT page
    nextTxtPage() {
        if (this.currentTxtPage < this.totalTxtPages) {
            this.currentTxtPage++;
            this.currentTxtPageContent = this.txtPages[this.currentTxtPage - 1];
        }
    },
    
    // NEW: Navigate to previous TXT page
    prevTxtPage() {
        if (this.currentTxtPage > 1) {
            this.currentTxtPage--;
            this.currentTxtPageContent = this.txtPages[this.currentTxtPage - 1];
        }
    },

  
    
    // Initialize navigation mode
    initializeNavigationMode() {
        if (this.currentBook.type === 'pdf') {
            this.currentPdfPage = 1;
            this.scrollToPdfPage(1);
        }
        // For EPUB, we'll use the existing nextPage/prevPage methods
    },
    
    // Cleanup navigation mode
    cleanupNavigationMode() {
        // Reset any navigation state if needed
        if (this.currentBook.type === 'pdf') {
            // Allow scrolling again
            const container = document.getElementById('pdf-container');
            if (container) {
                container.scrollTop = 0;
            }
        }
    },
    
    // PDF Navigation
    nextPdfPage() {
        if (this.currentPdfPage < this.pdfPages.length) {
            this.currentPdfPage++;
            this.scrollToPdfPage(this.currentPdfPage);
        }
    },
    
    prevPdfPage() {
        if (this.currentPdfPage > 1) {
            this.currentPdfPage--;
            this.scrollToPdfPage(this.currentPdfPage);
        }
    },
    
    scrollToPdfPage(pageNumber) {
        this.currentPdfPage = pageNumber;
        // The page will be shown/hidden via Vue's conditional rendering
        // Scroll to top of container
        const container = document.getElementById('pdf-navigation-container');
        if (container) {
            container.scrollTop = 0;
        }
        
        // Update progress for slider
        this.updatePdfProgress();
    },
    
    updatePdfProgress() {
        if (this.currentBook.type === 'pdf') {
            this.progress = (this.currentPdfPage / this.pdfPages.length) * 100;
        }
    },
    
    // Content scrolling for DOCX/TXT
    scrollContent(amount) {
        let container;
        if (this.currentBook.type === 'docx' || this.currentBook.type === 'doc') {
            container = document.querySelector('.content-navigation-view .docx-content');
        } else if (this.currentBook.type === 'txt') {
            container = document.querySelector('.content-navigation-view .txt-content');
        }
        
        if (container) {
            container.scrollTop += amount;
        }
    },
    
    // Update the existing onProgressChange method for PDF navigation
    onProgressChange(value) {
        if (this.currentBook.type === 'pdf') {
            if (this.navigationMode) {
                // In navigation mode, go to specific page
                const pageNumber = Math.ceil((value / 100) * this.pdfPages.length);
                this.scrollToPdfPage(pageNumber);
            } else {
                // In scroll mode, use existing behavior
                const pageNumber = Math.ceil((value / 100) * this.pdfPages.length);
                const pageElement = document.getElementById(`pdf-page-${pageNumber}`);
                if (pageElement) {
                    pageElement.scrollIntoView();
                }
            }
        } else if (this.currentBook.type === 'epub' && this.rendition) {
            const location = this.book.locations.cfiFromPercentage(value / 100);
            this.rendition.display(location);
        }
    },
    
    // Update closeBook to reset navigation state
    closeBook() {
        this.currentBook = null;
        this.isReady = false;
        this.loadError = null;
        this.rendition = null;
        this.book = null;
        this.pdfDoc = null;
        this.pdfPages = [];
        this.docxContent = '';
        this.txtContent = '';
        this.navigationMode = false; // Reset navigation mode
        this.currentPdfPage = 1; // Reset PDF page
    },
    // Handle window resize
    handleResize() {
        if (this.isMobile && this.currentTab === 'all') {
            this.currentTab = 'rentals';
        }
    },
    
    startQueueTimer() {
        // Update queue timers every second
        this.queueTimer = setInterval(() => {
            this.updateQueueTimers();
        }, 1000);
    },
    
    startCountdownTimer() {
        // Update countdown every minute
        this.countdownTimer = setInterval(() => {
            // Force Vue to update the view
            this.$forceUpdate();
        }, 60000); // Update every minute
    },
    
    // Check offline status
    checkOfflineStatus() {
        this.offlineMode = !navigator.onLine;
    },
    
                
                // API Helper
                async apiCall(endpoint, options = {}) {
                    const url = `${API_BASE}${endpoint}`;
                    const config = {
                        headers: {
                            'Content-Type': 'application/json',
                            ...options.headers
                        },
                        ...options
                    };

                    if (this.token) {
                        config.headers.Authorization = `Bearer ${this.token}`;
                    }

                    if (options.body) {
                        config.body = JSON.stringify(options.body);
                    }

                    try {
                        const response = await fetch(url, config);
                        const data = await response.json();
                        
                        if (!response.ok) {
                            throw new Error(data.error || 'Request failed');
                        }
                        
                        return data;
                    } catch (error) {
                        console.error('API call error:', error);
                        throw error;
                    }
                },
                
                // Authentication
                async handleLogin() {
                    this.$refs.loginForm.validate(async (valid) => {
                        if (!valid) return;
                        
                        this.loginLoading = true;
                        this.loginError = '';
                        
                        try {
                            const result = await this.apiCall('/auth/login', {
                                method: 'POST',
                                body: this.loginForm
                            });
                            
                            this.token = result.token;
                            this.user = result.user;
                            this.isAuthenticated = true;
                            
                            // Store in localStorage
                            localStorage.setItem('reader-token', this.token);
                            localStorage.setItem('reader-user', JSON.stringify(this.user));
                            
                            // Clear form
                            this.loginForm.email = '';
                            this.loginForm.password = '';
                            
                            // Load library and user data
                            await this.loadLibrary();
                            await this.loadUserData();
                            
                            // Start countdown timer
                            this.startCountdownTimer();
                            
                            this.$message.success('Login successful!');
                            
                        } catch (error) {
                            this.loginError = error.message;
                        } finally {
                            this.loginLoading = false;
                        }
                    });
                },
                
                async handleRegister() {
                    this.$refs.registerForm.validate(async (valid) => {
                        if (!valid) return;
                        
                        this.registerLoading = true;
                        
                        try {
                            const result = await this.apiCall('/auth/register', {
                                method: 'POST',
                                body: this.registerForm
                            });
                            
                            this.showRegister = false;
                            this.registerForm.name = '';
                            this.registerForm.email = '';
                            this.registerForm.password = '';
                            
                            this.$message.success('Registration successful! Please login.');
                            
                        } catch (error) {
                            this.$message.error('Registration failed: ' + error.message);
                        } finally {
                            this.registerLoading = false;
                        }
                    });
                },
                
                logout() {
                    this.token = null;
                    this.user = null;
                    this.isAuthenticated = false;
                    this.currentBook = null;
                    this.bookList = [];
                    this.userRentals = [];
                    this.userQueue = [];
                    
                    // Clear countdown timer
                    if (this.countdownTimer) {
                        clearInterval(this.countdownTimer);
                    }
                    
                    localStorage.removeItem('reader-token');
                    localStorage.removeItem('reader-user');
                    
                    this.$message.success('Logged out successfully');
                },
                
                // Navigation
                showLibrary() {
                    this.currentView = 'library';
                    this.currentBook = null;
                },
                
                showDashboard() {
                    this.currentView = 'dashboard';
                    this.currentTab = 'rentals';
                },
                
                // Data Loading
                async loadLibrary() {
                    try {
                        this.bookList = await this.apiCall('/books');
                    } catch (error) {
                        console.error('Error loading library:', error);
                        this.$message.error('Failed to load library: ' + error.message);
                    }
                },
                
                async loadUserData() {
                    try {
                        // Load rentals
                        this.userRentals = await this.apiCall('/user/rentals');
                        
                        // Load queue
                        this.userQueue = await this.apiCall('/user/queue');
                    } catch (error) {
                        console.error('Error loading user data:', error);
                    }
                },
                
                // Book Operations
async openBook(bookInfo) {
    try {
        // Check if user has access to this book
        const response = await this.apiCall(`/books/${bookInfo.id}/read`);
        
        this.currentBook = {
            ...bookInfo,
            type: bookInfo.file_type,
            file_path: response.book.file_path
        };
        
        this.isReady = false;
        this.loadError = null;
        
        // Set navigation mode to false by default (scroll mode)
        this.navigationMode = false;
        
        await this.loadDocument(this.currentBook);
        this.isReady = true;
        
    } catch (error) {
        console.error('Error opening book:', error);
        this.loadError = `Failed to open book: ${error.message}`;
        this.$message.error(`Error opening book: ${error.message}`);
    }
},
                
async openRentedBook(rental) {
    try {
        // Get book details
        const book = this.bookList.find(b => b.id === rental.book_id);
        if (!book) {
            throw new Error('Book not found');
        }
        
        this.currentBook = {
            ...book,
            type: book.file_type
        };
        
        this.isReady = false;
        this.loadError = null;
        
        // Set navigation mode to false by default (scroll mode)
        this.navigationMode = false;
        
        await this.loadDocument(this.currentBook);
        this.isReady = true;
        
    } catch (error) {
        console.error('Error opening rented book:', error);
        this.loadError = `Failed to open book: ${error.message}`;
        this.$message.error(`Error opening book: ${error.message}`);
    }
},
                    // Add this method to your Vue component methods
                async getQueueInfo(bookId) {
                    try {
                    const info = await this.apiCall(`/books/${bookId}/queue-info`);
                    return info;
                    } catch (error) {
                    console.error('Error getting queue info:', error);
                    return { totalInQueue: 0, userPosition: null, isInQueue: false };
                    }
                },
// Add these methods to your Vue component
async loadQueueDetails(bookId) {
    try {
        const details = await this.apiCall(`/books/${bookId}/queue-details`);
        return details;
    } catch (error) {
        console.error('Error loading queue details:', error);
        return { queue: [], userPosition: null, totalInQueue: 0, userInQueue: false };
    }
},
// Add this method to update timers in real-time
updateQueueTimers() {
    if (this.isAuthenticated && this.bookList.length > 0) {
        let needsRefresh = false;
        
        this.bookList.forEach(book => {
            if (book.queueInfo && book.queueInfo.timeRemaining) {
                // Update the time remaining every second
                if (book.queueInfo.timeRemaining > 0) {
                    book.queueInfo.timeRemaining -= 1000;
                    
                    // If timer just expired, mark for refresh
                    if (book.queueInfo.timeRemaining <= 0) {
                        needsRefresh = true;
                    }
                }
            }
        });
        
        // Force Vue to update the view
        this.$forceUpdate();
        
        // Refresh data if any timers expired
        if (needsRefresh) {
            setTimeout(() => {
                this.loadLibrary();
                this.loadUserData();
            }, 2000);
        }
    }
},



// Don't forget to clear the timer
beforeDestroy() {
    // Clear timer and event listener
    if (this.countdownTimer) {
        clearInterval(this.countdownTimer);
    }
    if (this.queueTimer) {
        clearInterval(this.queueTimer);
    }
    window.removeEventListener('resize', this.handleResize);
},
// Format time remaining for queue reservation
// Format time remaining for queue reservation - make it more user-friendly
formatQueueTimeRemaining(timeRemainingMs) {
  if (!timeRemainingMs || timeRemainingMs <= 0) return 'Expired!';
  
  const totalSeconds = Math.floor(timeRemainingMs / 1000);
  const days = Math.floor(totalSeconds / (3600 * 24));
  const hours = Math.floor((totalSeconds % (3600 * 24)) / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  
  if (days > 0) {
    return `${days} day${days > 1 ? 's' : ''} ${hours} hour${hours > 1 ? 's' : ''}`;
  } else if (hours > 0) {
    return `${hours} hour${hours > 1 ? 's' : ''} ${minutes} minute${minutes > 1 ? 's' : ''}`;
  } else {
    return `${minutes} minute${minutes > 1 ? 's' : ''}`;
  }
},
// Calculate queue expiry time
getQueueExpiryTime(addedAt) {
    const joinDate = new Date(addedAt);
    const expiryDate = new Date(joinDate.getTime() + (2 * 24 * 60 * 60 * 1000));
    return expiryDate;
},
// Update the rentBook method to handle queue priority
async rentBook(book) {
    try {
        const result = await this.apiCall('/books/rent', {
            method: 'POST',
            body: { bookId: book.id }
        });
        
        this.$message.success(`You have successfully rented "${book.title}" for 21 days`);
        
        // Reload data
        await this.loadLibrary();
        await this.loadUserData();
        
    } catch (error) {
        if (error.message.includes('Book not available')) {
            // Show queue option
            this.$confirm(
                `"${book.title}" is currently unavailable. Would you like to join the queue?`, 
                'Book Unavailable', 
                {
                    confirmButtonText: 'Join Queue',
                    cancelButtonText: 'Cancel',
                    type: 'warning'
                }
            ).then(async () => {
                await this.addToQueue(book);
            });
        } else if (error.message.includes('reserved for the first person')) {
            this.$message.warning('This book is reserved for the first person in queue. Please join the queue.');
        } else {
            this.$message.error('Error renting book: ' + error.message);
        }
    }
},
// Update the method to get queue status display
// Update the getQueueStatusDisplay method to be more accurate
getQueueStatusDisplay(book) {
    if (!book.queueInfo) {
        return { type: 'unknown', text: 'Loading...', class: 'status-unavailable' };
    }
    
    const queueInfo = book.queueInfo;
    
   
    if (queueInfo.hasReservation && queueInfo.timeRemaining > 0) {
        const timeRemaining = this.formatQueueTimeRemaining(queueInfo.timeRemaining);
        return { 
            type: 'reserved', 
            text: `Reserved for you! ‚è∞ ${timeRemaining} left`,
            class: 'status-first-queue'
        };
    } else if (queueInfo.hasReservation && queueInfo.timeRemaining <= 0) {
        return { 
            type: 'expired', 
            text: 'Reservation expired!',
            class: 'status-unavailable'
        };
    } else if (queueInfo.userInQueue && queueInfo.queueStatus === 'waiting') {
        return { 
            type: 'in-queue', 
            text: `Position ${queueInfo.userPosition} of ${queueInfo.totalInQueue} (Waiting)`,
            class: 'status-in-queue'
        };
    } else if (book.available_copies > 0 && queueInfo.totalInQueue === 0) {
        return { 
            type: 'available', 
            text: `${book.available_copies} available`,
            class: 'status-available'
        };
    } else if (book.available_copies > 0 && queueInfo.totalInQueue > 0) {
        return { 
            type: 'reserved', 
            text: `Reserved (${queueInfo.totalInQueue} in queue)`,
            class: 'status-reserved'
        };
    } else {
        return { 
            type: 'unavailable', 
            text: `Unavailable (${queueInfo.totalInQueue} in queue)`,
            class: 'status-unavailable'
        };
    }
},
                
                async rentBookFromQueue(queueItem) {
                    try {
                        await this.apiCall('/books/rent', {
                            method: 'POST',
                            body: { bookId: queueItem.book_id }
                        });
                        
                        this.$message.success(`You have successfully rented "${queueItem.title}" for 21 days`);
                        
                        // Remove from queue and reload data
                        await this.removeFromQueue(queueItem);
                        await this.loadLibrary();
                        await this.loadUserData();
                        
                    } catch (error) {
                        console.error('Error renting book from queue:', error);
                        this.$message.error('Error renting book: ' + error.message);
                    }
                },
                
async addToQueue(book) {
    try {
        const result = await this.apiCall('/queue/add', {
            method: 'POST',
            body: { bookId: book.id }
        });
        
        let message = `"${book.title}" has been added to your queue. `;
        message += `You are position ${result.position} of ${result.totalInQueue}.`;
        
        if (result.availableCopies > 0) {
            message += ` There are ${result.availableCopies} copies available, but ${result.totalInQueue} people are waiting.`;
        }
        
        this.$message.success(message);
        
        // Reload user data and library to update the UI
        await this.loadLibrary();
        await this.loadUserData();
        
    } catch (error) {
        if (error.message.includes('Book is available for direct rental')) {
            // This should rarely happen now, but handle it gracefully
            this.$message.info('This book is currently available for direct rental. Try renting it directly.');
        } else {
            console.error('Error adding to queue:', error);
            this.$message.error('Error adding to queue: ' + error.message);
        }
    }
},
// Add computed property for queue display
computed: {
    filteredBooks() {
        if (this.currentTab === 'available') {
            return this.bookList.filter(book => book.available_copies > 0);
        }
        return this.bookList;
    },
    
    // Check if we're on mobile
    isMobile() {
        return window.innerWidth <= 900;
    },
    
    // Books that are unavailable but can be queued
    queuableBooks() {
        return this.bookList.filter(book => 
            book.available_copies <= 0 && 
            !this.hasRentedBook(book.id) && 
            !this.hasQueuedBook(book.id)
        );
    }
},
// Add this method to format queue information
getQueueDisplay(book) {
    if (book.available_copies > 0) {
        return {
            text: `${book.available_copies} available`,
            type: 'available',
            class: 'status-available'
        };
    } else {
        // This would be enhanced with actual queue data from the API
        return {
            text: 'Join queue',
            type: 'queue',
            class: 'status-queue'
        };
    }
},
                
                async removeFromQueue(queueItem) {
                    try {
                        await this.apiCall('/queue/remove', {
                            method: 'DELETE',
                            body: { queueId: queueItem.id }
                        });
                        
                        this.$message.success('Removed from queue');
                        
                        // Reload user data
                        await this.loadUserData();
                        
                    } catch (error) {
                        console.error('Error removing from queue:', error);
                        this.$message.error('Error removing from queue: ' + error.message);
                    }
                },
                
async returnBook(rental) {
    try {
        // Return book to library
        await this.apiCall('/books/return', {
            method: 'POST',
            body: {
                rentalId: rental.id,
                bookId: rental.book_id
            }
        });
        
        // Remove downloaded copy from secure storage
        try {
            await secureStorage.removeBook(rental.book_id);
            console.log(`Downloaded book ${rental.book_id} removed successfully`);
        } catch (downloadError) {
            console.warn('Could not remove downloaded book:', downloadError);
            // Continue with return even if download removal fails
        }
        
        // Update downloaded books list
        await this.loadDownloadedBooks();
        
        this.$message.success('Book returned successfully' + 
            (this.offlineMode ? '' : ' and removed from downloads'));
        
        // Reload library and user data
        await this.loadLibrary();
        await this.loadUserData();
        
    } catch (error) {
        console.error('Error returning book:', error);
        this.$message.error('Error returning book: ' + error.message);
    }
},
                // Helper methods
                hasRentedBook(bookId) {
                    return this.userRentals.some(rental => rental.book_id === bookId);
                },
                
                hasQueuedBook(bookId) {
                    return this.userQueue.some(item => item.book_id === bookId);
                },
                
                isBookAvailable(bookId) {
                    const book = this.bookList.find(b => b.id === bookId);
                    return book && book.available_copies > 0;
                },
                
                getBookFileType(bookId) {
                    const book = this.bookList.find(b => b.id === bookId);
                    return book ? book.file_type : null;
                },
                
                getRentalStatusClass(rental) {
                    const dueDate = new Date(rental.due_date);
                    const today = new Date();
                    const daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    
                    if (daysUntilDue < 0) {
                        return 'status-overdue';
                    } else if (daysUntilDue <= 3) {
                        return 'status-due';
                    } else {
                        return 'status-active';
                    }
                },
                
                getRentalStatusText(rental) {
                    const dueDate = new Date(rental.due_date);
                    const today = new Date();
                    const daysUntilDue = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
                    
                    if (daysUntilDue < 0) {
                        return `Overdue by ${Math.abs(daysUntilDue)} days`;
                    } else if (daysUntilDue <= 3) {
                        return `Due in ${daysUntilDue} days`;
                    } else {
                        return 'Active';
                    }
                },
                
                // Countdown timer methods
                getTimeRemaining(rental) {
                    const dueDate = new Date(rental.due_date);
                    const now = new Date();
                    const diff = dueDate - now;
                    
                    if (diff <= 0) {
                        return 'Overdue!';
                    }
                    
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    
                    if (days > 0) {
                        return `${days}d ${hours}h ${minutes}m`;
                    } else if (hours > 0) {
                        return `${hours}h ${minutes}m`;
                    } else {
                        return `${minutes}m`;
                    }
                },
                
                getCountdownClass(rental) {
                    const dueDate = new Date(rental.due_date);
                    const now = new Date();
                    const diff = dueDate - now;
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    
                    if (diff <= 0) {
                        return 'countdown-overdue';
                    } else if (days <= 1) {
                        return 'countdown-due';
                    } else {
                        return 'countdown-normal';
                    }
                },
                
                startCountdownTimer() {
                    // Update countdown every minute
                    this.countdownTimer = setInterval(() => {
                        // Force Vue to update the view
                        this.$forceUpdate();
                    }, 60000); // Update every minute
                },
                
                formatDate(dateString) {
                    return new Date(dateString).toLocaleDateString();
                },
                
                // Document Loading
                async loadDocument(book) {
                    const fileUrl = `http://localhost:3000${book.file_path}`;
                    
                    switch(book.type) {
                        case 'pdf':
                            await this.loadPDF(fileUrl);
                            break;
                        case 'docx':
                        case 'doc':
                            await this.loadDOCX(fileUrl);
                            break;
                        case 'txt':
                            await this.loadTXT(fileUrl);
                            break;
                        case 'epub':
                            await this.loadEPUB(fileUrl);
                            break;
                        default:
                            throw new Error(`Unsupported file type: ${book.type}`);
                    }
                },
                // Add to methods section
// Add this method to your Vue methods
async downloadRentedBook(rental) {
    if (!navigator.onLine) {
        this.$message.warning('Cannot download while offline');
        return;
    }

    try {
        // Find the full book details from bookList
        const book = this.bookList.find(b => b.id === rental.book_id);
        
        if (!book) {
            throw new Error('Book details not found');
        }
        
        if (!book.file_path) {
            throw new Error('Book file is not available for download');
        }
        
        this.$message.info(`Downloading "${book.title}" securely...`);
        
        const fileUrl = `http://localhost:3000${book.file_path}`;
        console.log('Download URL:', fileUrl);
        
        const response = await fetch(fileUrl, {
            headers: {
                'Authorization': `Bearer ${this.token}`
            }
        });
        
        if (!response.ok) throw new Error('Failed to download book file');
        
        const arrayBuffer = await response.arrayBuffer();
        
        // Use rental due date for expiry
        const expiryDate = new Date(rental.due_date);
        
        // Prepare book data for encryption
   const bookData = {
    id: book.id,
    title: book.title,
    author: book.author,
    file_type: book.file_type, // Explicitly include file_type
    file_path: book.file_path, // Keep file_path for reference
    cover_image: book.cover_image,
    fileContent: Array.from(new Uint8Array(arrayBuffer)),
    downloadedAt: new Date().toISOString(),
    expiryDate: expiryDate.toISOString()
};
        // Encrypt and save
        await secureStorage.saveBook(book.id, bookData, expiryDate);
        
        // Update downloaded books list
        await this.loadDownloadedBooks();
        
        this.$message.success(`"${book.title}" downloaded securely for offline reading`);
        
    } catch (error) {
        console.error('Download error:', error);
        this.$message.error(`Download failed: ${error.message}`);
    }
},
// Download book for offline reading
async downloadBook(item) {
    if (!navigator.onLine) {
        this.$message.warning('Cannot download while offline');
        return;
    }

    try {
        let book, expiryDate;
        
        // Check if it's a rental (has book_id) or a book object
        if (item.book_id) {
            // It's a rental - find the book and use rental due date
            book = this.bookList.find(b => b.id === item.book_id);
            expiryDate = new Date(item.due_date);
        } else {
            // It's a book object - use it directly
            book = item;
            expiryDate = new Date(Date.now() + 21 * 24 * 60 * 60 * 1000);
        }
        
        if (!book) {
            throw new Error('Book details not found');
        }
        
        if (!book.file_path) {
            throw new Error('Book file is not available for download');
        }
        
        this.$message.info(`Downloading "${book.title}" securely...`);
        
        const fileUrl = `http://localhost:3000${book.file_path}`;
        console.log('Download URL:', fileUrl);
      
        
        const response = await fetch(fileUrl, {
            headers: {
                'Authorization': `Bearer ${this.token}`
            }
        });
        
        if (!response.ok) throw new Error('Failed to download book file');
        
        const arrayBuffer = await response.arrayBuffer();
        
      const bookData = {
    ...book,
    file_type: book.file_type, // Ensure file_type is explicitly included
    fileContent: Array.from(new Uint8Array(arrayBuffer)),
    downloadedAt: new Date().toISOString(),
    expiryDate: expiryDate.toISOString()
};
        
        // Encrypt and save
        await secureStorage.saveBook(book.id, bookData, expiryDate);
        
        // Update downloaded books list
        await this.loadDownloadedBooks();
        
        this.$message.success(`"${book.title}" downloaded securely for offline reading`);
        
    } catch (error) {
        console.error('Download error:', error);
        this.$message.error(`Download failed: ${error.message}`);
    }
},

// Load downloaded books from secure storage
async loadDownloadedBooks() {
    try {
        await secureStorage.cleanupExpired();
        const encryptedBooks = await secureStorage.getAllBooks();
        this.downloadedBooks = [];
        
        for (const encryptedBook of encryptedBooks) {
            try {
                const decryptedData = await secureStorage.decryptData(encryptedBook.data);
                
                // Use the decrypted data directly
                this.downloadedBooks.push({
                    ...decryptedData, // This contains the book data with file_type, fileContent, etc.
                    encryptedId: encryptedBook.id,
                    expiry: encryptedBook.expiry,
                    // Ensure file_type is preserved
                    file_type: decryptedData.file_type || this.determineFileType(decryptedData)
                });
                
            } catch (error) {
                console.error('Failed to decrypt book:', error);
                // Remove corrupted book
                await secureStorage.removeBook(encryptedBook.id);
            }
        }
    } catch (error) {
        console.error('Error loading downloaded books:', error);
    }
},
// Helper method to determine file type from various sources
determineFileType(book) {
    // Priority 1: Direct file_type property
    if (book.file_type) return book.file_type;
    
    // Priority 2: From file_path extension
    if (book.file_path) {
        const extension = book.file_path.split('.').pop().toLowerCase();
        if (['pdf', 'docx', 'doc', 'txt', 'epub'].includes(extension)) {
            return extension;
        }
    }
    
    // Priority 3: From type property
    if (book.type) return book.type;
    
    // Priority 4: From original file_type if available
    if (book.original_file_type) return book.original_file_type;
    
    // Default fallback
    return 'unknown';
},

// Open downloaded book
async openDownloadedBook(book) {
    try {
        console.log('Opening downloaded book:', book);
        
        // Ensure the book has a valid file_type using our helper method
        const fileType = this.determineFileType(book);
        
        if (!fileType || fileType === 'unknown') {
            throw new Error('Cannot determine file type for downloaded book');
        }

        this.currentBook = {
            ...book,
            type: fileType,
            file_type: fileType,
            offline: true
        };
        
        this.isReady = false;
        this.loadError = null;
        
        // Set navigation mode to false by default (scroll mode)
        this.navigationMode = false;
        
        // For downloaded books, we already have the file content
        await this.loadDownloadedDocument(book);
        this.isReady = true;
        
    } catch (error) {
        console.error('Error opening downloaded book:', error);
        this.loadError = `Failed to open book: ${error.message}`;
        this.$message.error(`Error opening book: ${error.message}`);
    }
},
// Load document from downloaded content
async loadDownloadedDocument(book) {
    try {
        console.log('Loading downloaded document:', book);
        
        if (!book.fileContent || !book.fileContent.length) {
            throw new Error('No file content found in downloaded book');
        }

        const arrayBuffer = new Uint8Array(book.fileContent).buffer;
        
        // Use the helper method to ensure we have a valid file type
        const fileType = this.determineFileType(book);
        
        if (!fileType || fileType === 'unknown') {
            throw new Error('File type is undefined or unknown for downloaded book');
        }

        switch(fileType.toLowerCase()) {
            case 'pdf':
                await this.loadPDFFromBuffer(arrayBuffer);
                break;
            case 'docx':
            case 'doc':
                await this.loadDOCXFromBuffer(arrayBuffer);
                break;
            case 'txt':
                await this.loadTXTFromBuffer(arrayBuffer);
                break;
            case 'epub':
                await this.loadEPUBFromBuffer(arrayBuffer);
                break;
            default:
                throw new Error(`Unsupported file type: ${fileType}`);
        }
    } catch (error) {
        console.error('Error loading downloaded document:', error);
        throw error;
    }
},
// PDF from buffer
async loadPDFFromBuffer(arrayBuffer) {
    this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
    this.pdfPages = [];
    
    for (let i = 1; i <= this.pdfDoc.numPages; i++) {
        this.pdfPages.push({ pageNumber: i });
    }
    
    await this.renderPDFPages();
},

// DOCX from buffer
async loadDOCXFromBuffer(arrayBuffer) {
    if (typeof mammoth === 'undefined') {
        throw new Error('DOCX library not loaded');
    }
    
    const result = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer });
    
    if (result.value) {
        this.docxContent = result.value;
    } else {
        throw new Error('No content could be extracted from the document');
    }
},

// TXT from buffer
async loadTXTFromBuffer(arrayBuffer) {
    const decoder = new TextDecoder();
    this.txtContent = decoder.decode(arrayBuffer);
    
    if (!this.txtContent.trim()) {
        throw new Error('File appears to be empty');
    }
},

// EPUB from buffer
async loadEPUBFromBuffer(arrayBuffer) {
    this.book = ePub(arrayBuffer);
    
    this.rendition = this.book.renderTo("epub-container", {
        width: "100%",
        height: "100%"
    });
    
    this.rendition.display();
    
    this.rendition.on("relocated", (location) => {
        this.updateProgress();
    });
},

// Remove downloaded book
async removeDownloadedBook(book) {
    try {
        await secureStorage.removeBook(book.id);
        await this.loadDownloadedBooks();
        this.$message.success('Book removed from downloads');
    } catch (error) {
        console.error('Error removing downloaded book:', error);
        this.$message.error('Failed to remove book');
    }
},

// Download countdown methods
getDownloadTimeRemaining(book) {
    const expiryDate = new Date(book.expiry);
    const now = new Date();
    const diff = expiryDate - now;
    
    if (diff <= 0) {
        return 'Expired';
    }
    
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    
    if (days > 0) {
        return `${days}d ${hours}h`;
    } else {
        return `${hours}h`;
    }
},

getDownloadCountdownClass(book) {
    const expiryDate = new Date(book.expiry);
    const now = new Date();
    const diff = expiryDate - now;
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    
    if (diff <= 0) {
        return 'countdown-overdue';
    } else if (days <= 1) {
        return 'countdown-due';
    } else {
        return 'countdown-normal';
    }
},

// Check offline status
checkOfflineStatus() {
    this.offlineMode = !navigator.onLine;
},
                // EPUB Loader
                async loadEPUB(url) {
                    try {
                        const response = await fetch(url, {
                            headers: {
                                'Authorization': `Bearer ${this.token}`
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to fetch EPUB file');
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        this.book = ePub(arrayBuffer);
                        
                        this.rendition = this.book.renderTo("epub-container", {
                            width: "100%",
                            height: "100%"
                        });
                        
                        this.rendition.display();
                        
                        // Set up navigation handlers
                        this.rendition.on("relocated", (location) => {
                            this.updateProgress();
                        });
                        
                    } catch (error) {
                        throw new Error(`EPUB loading failed: ${error.message}`);
                    }
                },
                
                // PDF Loader
                async loadPDF(url) {
                    try {
                        const response = await fetch(url, {
                            headers: {
                                'Authorization': `Bearer ${this.token}`
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to fetch PDF file');
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        this.pdfDoc = await pdfjsLib.getDocument(arrayBuffer).promise;
                        this.pdfPages = [];
                        
                        for (let i = 1; i <= this.pdfDoc.numPages; i++) {
                            this.pdfPages.push({ pageNumber: i });
                        }
                        
                        await this.renderPDFPages();
                    } catch (error) {
                        throw new Error(`PDF loading failed: ${error.message}`);
                    }
                },
                
                async renderPDFPages() {
                    for (let page of this.pdfPages) {
                        const pdfPage = await this.pdfDoc.getPage(page.pageNumber);
                        const canvas = document.getElementById(`pdf-page-${page.pageNumber}`);
                        if (!canvas) continue;
                        
                        const context = canvas.getContext('2d');
                        const viewport = pdfPage.getViewport({ scale: this.zoomLevel * 1.5 });
                        
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        
                        await pdfPage.render({
                            canvasContext: context,
                            viewport: viewport
                        }).promise;
                    }
                },
                
                // DOCX/DOC Loader
                async loadDOCX(url) {
                    try {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX library not loaded. Please check your internet connection.');
                        }
                        
                        const response = await fetch(url, {
                            headers: {
                                'Authorization': `Bearer ${this.token}`
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error('Failed to fetch DOCX file');
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        const result = await mammoth.convertToHtml({ arrayBuffer: arrayBuffer });
                        
                        if (result.value) {
                            this.docxContent = result.value;
                        } else {
                            throw new Error('No content could be extracted from the document');
                        }
                    } catch (error) {
                        console.error('DOCX conversion error:', error);
                        this.docxContent = `
                            <div style="text-align: center; padding: 50px;">
                                <h3>Unable to display DOCX content</h3>
                                <p>Error: ${error.message}</p>
                                <p>Try downloading the file and opening it with Microsoft Word or LibreOffice.</p>
                            </div>
                        `;
                        throw error;
                    }
                },
                
              // TXT Loader
// TXT Loader - improved
async loadTXT(url) {
    try {
        const response = await fetch(url, {
            headers: {
                'Authorization': `Bearer ${this.token}`
            }
        });
        
        if (!response.ok) {
            throw new Error('Failed to fetch text file');
        }
        
        this.txtContent = await response.text();
        if (!this.txtContent.trim()) {
            throw new Error('File appears to be empty');
        }
        
        // Initialize pagination only if navigation mode is active
        if (this.navigationMode) {
            this.paginateTxtContent();
        }
    } catch (error) {
        throw new Error(`Text file loading failed: ${error.message}`);
    }
},
                // Navigation Methods
                closeBook() {
                    this.currentBook = null;
                    this.isReady = false;
                    this.loadError = null;
                    this.rendition = null;
                    this.book = null;
                    this.pdfDoc = null;
                    this.pdfPages = [];
                    this.docxContent = '';
                    this.txtContent = '';
                },
                
                prevPage() {
                    if (this.rendition) {
                        this.rendition.prev();
                    }
                },
                
                nextPage() {
                    if (this.rendition) {
                        this.rendition.next();
                    }
                },
                
                goBack() {
                    if (this.currentBook.type === 'pdf') {
                        const container = document.getElementById('pdf-container');
                        container.scrollTop -= 500;
                    } else {
                        // For DOCX/TXT, scroll up
                        const container = document.querySelector('.reader-content');
                        container.scrollTop -= 200;
                    }
                },
                
                zoomIn() {
                    this.zoomLevel = Math.min(3.0, this.zoomLevel + 0.1);
                    this.applyZoom();
                },
                
                zoomOut() {
                    this.zoomLevel = Math.max(0.5, this.zoomLevel - 0.1);
                    this.applyZoom();
                },
                // Your existing EPUB methods will work in both modes
prevPage() {
    if (this.rendition) {
        this.rendition.prev();
        this.updateProgress();
    }
},

nextPage() {
    if (this.rendition) {
        this.rendition.next();
        this.updateProgress();
    }
},
              applyZoom() {
    const effectiveSize = this.fontSize * this.zoomLevel;
    
    if (this.currentBook.type === 'pdf') {
        this.renderPDFPages();
    } else if (this.currentBook.type === 'docx' || this.currentBook.type === 'doc') {
        const content = document.querySelector('.docx-content');
        if (content) {
            content.style.fontSize = `${effectiveSize}px`;
        }
    } else if (this.currentBook.type === 'txt') {
        // Apply zoom to both navigation and scroll modes
        const navContent = document.querySelector('.navigation-mode .txt-content');
        const scrollContent = document.querySelector('.scroll-mode.txt-content');
        
        if (navContent) {
            navContent.style.fontSize = `${effectiveSize}px`;
        }
        if (scrollContent) {
            scrollContent.style.fontSize = `${effectiveSize}px`;
        }
    }
},
                applyTheme() {
                    // Save theme to localStorage
                    localStorage.setItem('reader-theme', this.theme);
                    
                    // Update PDF container background
                    this.updatePDFBackground();
                },
                
                updatePDFBackground() {
                    if (this.currentBook && this.currentBook.type === 'pdf') {
                        const pdfContainer = document.getElementById('pdf-container');
                        if (pdfContainer) {
                            // Background color will be applied via CSS based on theme class
                        }
                    }
                },
                
                toggleSearch() {
                    this.searchVisible = !this.searchVisible;
                    this.searchText = '';
                    this.searchResults = [];
                },
                
                onSearch() {
                    if (!this.searchText.trim()) {
                        this.searchResults = [];
                        return;
                    }
                    
                    const searchTerm = this.searchText.toLowerCase();
                    this.searchResults = [];
                    
                    if (this.currentBook.type === 'txt') {
                        const lines = this.txtContent.split('\n');
                        lines.forEach((line, index) => {
                            if (line.toLowerCase().includes(searchTerm)) {
                                this.searchResults.push({
                                    text: line.trim() || '(empty line)',
                                    index: index,
                                    type: 'line'
                                });
                            }
                        });
                    } else if (this.currentBook.type === 'docx' || this.currentBook.type === 'doc') {
                        // Simple text search in DOCX content
                        const textContent = this.docxContent.replace(/<[^>]*>/g, ' ');
                        const sentences = textContent.split(/[.!?]+/).filter(s => s.trim());
                        sentences.forEach((sentence, index) => {
                            if (sentence.toLowerCase().includes(searchTerm)) {
                                this.searchResults.push({
                                    text: sentence.trim().substring(0, 100) + '...',
                                    index: index,
                                    type: 'sentence'
                                });
                            }
                        });
                    }
                    
                    // Limit results
                    this.searchResults = this.searchResults.slice(0, 20);
                },
                
                goToSearchResult(result) {
                    if (this.currentBook.type === 'txt') {
                        const txtElement = document.querySelector('.txt-content');
                        const lines = this.txtContent.split('\n');
                        const approxPosition = (result.index / lines.length) * txtElement.scrollHeight;
                        txtElement.scrollTop = approxPosition;
                    }
                    this.searchVisible = false;
                },
                
showSettings() {
    if (!navigator.onLine) {
        this.$message.warning('Settings unavailable while offline');
        return;
    }
    this.settingsVisible = true;
},

                
                updateProgress() {
                    if (this.rendition && this.book) {
                        const currentLocation = this.rendition.currentLocation();
                        if (currentLocation && currentLocation.start) {
                            const percentage = (currentLocation.start.percentage * 100);
                            this.progress = Math.round(percentage * 10) / 10;
                        }
                    }
                },
                
                onProgressChange(value) {
                    if (this.currentBook.type === 'pdf') {
                        const pageNumber = Math.ceil((value / 100) * this.pdfDoc.numPages);
                        const pageElement = document.getElementById(`pdf-page-${pageNumber}`);
                        if (pageElement) {
                            pageElement.scrollIntoView();
                        }
                    } else if (this.currentBook.type === 'epub' && this.rendition) {
                        const location = this.book.locations.cfiFromPercentage(value / 100);
                        this.rendition.display(location);
                    }
                },
                
                formatProgress(value) {
                    return `${value.toFixed(1)}%`;
                }
            },
            
            watch: {
                fontSize() {
                    this.applyZoom();
                },
                
                zoomLevel() {
                    this.applyZoom();
                },
                navigationMode(newVal) {
        // Save navigation preference
        localStorage.setItem('reader-navigation-mode', newVal.toString());
    }
            }
        });
        // Enhanced offline detection
function handleOfflineMode() {
    const isOffline = !navigator.onLine;
    
    // Update Vue instance offline status
    if (window.vueInstance) {
        window.vueInstance.offlineMode = isOffline;
    }
    
    if (isOffline) {
        // Hide all online-only dialogs
        const wrappers = document.querySelectorAll('.el-dialog__wrapper, .v-modal');
        wrappers.forEach(wrapper => {
            wrapper.style.display = 'none';
            wrapper.style.visibility = 'hidden';
            wrapper.style.opacity = '0';
            wrapper.style.zIndex = '-1000';
        });
        
        const dialogs = document.querySelectorAll("#offlinetoremove");
        dialogs.forEach(dialog => {
            dialog.style.display = 'none';
            dialog.style.visibility = 'hidden';
            dialog.style.opacity = '0';
        });
        
    }
}



// Check offline status every second and on events
setInterval(handleOfflineMode, 1000);
window.addEventListener('online', handleOfflineMode);
window.addEventListener('offline', handleOfflineMode);
handleOfflineMode();
// Force hide ALL Element UI dialogs when offline
function hideDialogsWhenOffline() {
    if (!navigator.onLine) {
        // Hide all dialog wrappers and backdrops
        const wrappers = document.querySelectorAll('.el-dialog__wrapper, .v-modal');
        wrappers.forEach(wrapper => {
            wrapper.style.display = 'none';
            wrapper.style.visibility = 'hidden';
            wrapper.style.opacity = '0';
            wrapper.style.zIndex = '-1000';
        });
        
        // Also hide the actual dialogs
        const dialogs = document.querySelectorAll("#offlinetoremove");
        dialogs.forEach(dialog => {
            dialog.style.display = 'none';
            dialog.style.visibility = 'hidden';
            dialog.style.opacity = '0';
        });
        const BUTTOMS = document.querySelectorAll("buttons");

        const books =document.querySelectorAll(".offlinebutton");
        books.forEach(book=>{
            book.style.opacity='0.1';
            book.style.addEventListener("click",()=>{
                alert("the book is not available offline");
            })
        });
    }
}

// Check every 100ms and hide dialogs when offline
setInterval(hideDialogsWhenOffline, 100);

// Also run immediately
hideDialogsWhenOffline();

// Listen for online/offline events
window.addEventListener('online', hideDialogsWhenOffline);
window.addEventListener('offline', hideDialogsWhenOffline);
    </script>
</body>
</html>